<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Vibe Pomodoro â€” Nebula + Meteors (Down-Right) + Drift Stars (No Trail) + Cute Rocket Heart</title>
  <style>
    :root{
      --bg0:#040611;
      --bg1:#050a1a;

      --cA: 300;
      --cB: 205;
      --cC: 275;

      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.65);

      --uiBorder: rgba(255,255,255,.14);
      --shadow: 0 18px 46px rgba(0,0,0,.45);
    }

    *{ box-sizing:border-box; }
    html, body{ height:100%; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans TC", "PingFang TC", Arial;
      color: var(--text);
      background:
        radial-gradient(1100px 700px at 12% 15%, rgba(160,120,255,.12), transparent 55%),
        radial-gradient(900px 650px at 88% 20%, rgba(90,210,255,.10), transparent 55%),
        radial-gradient(900px 700px at 50% 92%, rgba(255,120,210,.08), transparent 60%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      min-height:100vh;
      overflow:hidden;

      /* è®“ä¸»ä»‹é¢ç½®ä¸­ï¼ˆéè¶…å°ˆæ³¨æ¨¡å¼ï¼‰ */
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 24px 14px;
    }

    canvas#viz{
      position:fixed;
      inset:0;
      width:100vw;
      height:100vh;
      z-index:0;
      pointer-events:none;
      filter: saturate(1.2) contrast(1.08);
    }

    .ui{
      position:relative;
      z-index:2;

      /* æ¯”è¶…å°ˆæ³¨æ¡†æ›´å¤§ã€ç½®ä¸­ã€ç»ç’ƒ + è³½åšé¾å…‹ HUD é¢¨ */
      width: min(980px, 94vw);
      margin: 0;
      padding: 26px 26px 22px;
      display:flex;
      flex-direction:column;
      gap: 14px;

      border-radius: 26px;
      border: 1px solid rgba(255,255,255,.16);
      background:
        radial-gradient(900px 420px at 20% 10%, rgba(90,210,255,.10), transparent 60%),
        radial-gradient(800px 420px at 85% 20%, rgba(255,120,210,.10), transparent 62%),
        linear-gradient(180deg, rgba(8,12,28,.68), rgba(10,10,24,.52));
      backdrop-filter: blur(16px) saturate(140%);
      box-shadow:
        0 20px 65px rgba(0,0,0,.48),
        0 0 0 1px rgba(90,210,255,.10);
    }
    /* HUD è£é£¾ï¼šä¸Šæ–¹éœ“è™¹æƒæç·š */
    .ui::after{
      content:"";
      position:absolute;
      left: 22px;
      right: 22px;
      top: 14px;
      height: 2px;
      border-radius: 999px;
      background: linear-gradient(90deg,
        transparent,
        rgba(90,210,255,.65),
        rgba(255,120,210,.55),
        transparent
      );
      opacity: .55;
      pointer-events:none;
    }
    /* HUD è£é£¾ï¼šå¾®å¼±æ ¼ç·š */
    .ui::before{
      content:"";
      position:absolute;
      inset: 0;
      border-radius: 26px;
      background:
        linear-gradient(rgba(255,255,255,.035) 1px, transparent 1px),
        linear-gradient(90deg, rgba(255,255,255,.028) 1px, transparent 1px);
      background-size: 34px 34px;
      mask-image: radial-gradient(120% 120% at 50% 10%, rgba(0,0,0,.85), rgba(0,0,0,0));
      opacity: .9;
      pointer-events:none;

    .ui > *{ position:relative; z-index:1; }
    }

    .top{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap: 12px;
      padding: 6px 2px 14px;
      border-bottom: 1px solid rgba(255,255,255,.10);
    }
    @media (max-width:720px){
      .top{ flex-direction:column; align-items:stretch; }
      .chips{ justify-content:flex-start; }
    }

    .brand{ display:flex; align-items:center; gap:10px; user-select:none; }
    .dot{
      width:12px;height:12px;border-radius:999px;
      background: linear-gradient(90deg,
        hsla(var(--cB),100%,70%,.95),
        hsla(var(--cA),100%,70%,.95)
      );
      box-shadow: 0 0 18px rgba(120,200,255,.35);
    }
    .title{ font-weight: 950; letter-spacing:.2px; }
    .subtitle{
      font-size: 12px;
      color: var(--muted);
      margin-top: 4px;
      line-height: 1.35;
      max-width: 56ch;
    }

    .chips{ display:flex; align-items:center; gap:8px; flex-wrap:wrap; padding: 6px 8px; border:1px solid rgba(255,255,255,.10); border-radius: 999px; background: rgba(0,0,0,.18); }
    .chip{
      font-size:12px;
      padding: 9px 12px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.05);
      color: rgba(255,255,255,.72);
      cursor:pointer;
      user-select:none;
      transition: .15s transform, .15s background, .15s border, .15s color;
    }
    .chip:hover{ transform: translateY(-1px); color: var(--text); }
    .chip.active{
      background: rgba(120,200,255,.12);
      border-color: rgba(120,200,255,.35);
      color: var(--text);
    }

    .centerTimer{
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      padding-top: 14px;
      gap: 10px;
    }

    .bigTime{
      font-size: 64px;
      font-weight: 980;
      letter-spacing: 1px;
      text-shadow:
        0 2px 0 rgba(0,0,0,.35),
        0 6px 18px rgba(0,0,0,.55),
        0 0 22px rgba(120,200,255,.12),
        0 0 48px rgba(220,120,255,.10);
    }
    @media (max-width:520px){ .bigTime{font-size:56px;} }

    .modeLine{ font-size:13px; color: rgba(255,255,255,.78); letter-spacing: .5px; }

    .btns{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      justify-content:center;
      margin-top: 10px;
    }
    button{
      appearance:none;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding: 12px 14px;
      border-radius: 14px;
      cursor:pointer;
      user-select:none;
      font-weight: 900;
      transition: .15s transform, .15s background, .15s border;
    }
    button:hover{ transform: translateY(-1px); background: rgba(255,255,255,.10); }
    .primary{
      background: linear-gradient(90deg,
        hsla(var(--cB),100%,70%,.18),
        hsla(var(--cA),100%,70%,.14)
      );
      border-color: rgba(120,200,255,.32);
    }
    .danger{
      border-color: rgba(255,85,85,.35);
      background: rgba(255,85,85,.08);
    }
    .small{ padding: 10px 12px; border-radius: 12px; font-size: 13px; }

    .musicDock{
      position: fixed;
      right: 14px;
      bottom: 14px;
      z-index: 3;

      border:1px solid var(--uiBorder);
      background: rgba(255,255,255,.06);
      backdrop-filter: blur(12px);
      box-shadow: var(--shadow);
      border-radius: 18px;
      padding: 14px;
      width: min(420px, calc(100vw - 28px));
      font-size: 14px; /* æ•´é«”æ”¾å¤§ä¸€é» */
    }
    .musicTitle{
      font-weight: 950;
      font-size: 15px;
      margin-bottom: 10px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
    }
    .musicTitle span{ color: rgba(255,255,255,.72); font-weight: 850; font-size: 13px; }

    select, input[type="file"]{
      width: 100%;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.07);
      color: var(--text);
      padding: 12px 12px;
      font-weight: 950;
      font-size: 14px;
      outline:none;
    }
    .musicRow{ display:flex; gap:10px; margin-top: 10px; flex-wrap:wrap; }
    .musicRow button{ flex:1; }
    .volRow{
      display:flex; align-items:center; gap:10px; margin-top:10px;
      color: rgba(255,255,255,.78);
      font-size:13px;
    }
    input[type="range"]{ width: 100%; }

    .status{
      margin-top:10px;
      font-size: 13px;
      color: rgba(255,255,255,.65);
      line-height:1.35;
    }
    .ok{ color: rgba(80,250,123,.95); }
    .bad{ color: rgba(255,85,85,.95); }


    /* --- Music dock: bigger controls for clarity --- */
    .musicDock button{
      padding: 12px 12px;
      border-radius: 14px;
      font-size: 14px;
      font-weight: 950;
    }
    .musicDock .small{ font-size: 14px; padding: 12px 12px; border-radius: 14px; }
    .playlistHint{
      margin-top: 8px;
      font-size: 12.5px;
      color: rgba(255,255,255,.68);
      line-height: 1.45;
    }


    .focusOverlay{
      position: fixed;
      inset:0;
      z-index: 4;
      display:none;
      align-items:center;
      justify-content:center;
      pointer-events:none;
    }
    body.focusing .focusOverlay{ display:flex; }

    .orbHUD{
      width: min(560px, 92vw);
      text-align:center;
      transform: translateY(-2%);
      pointer-events:none;
      user-select:none;
    }

    .orbTime{
      font-size: 72px;
      font-weight: 980;
      letter-spacing: 1px;
      text-shadow:
        0 1px 0 rgba(0,0,0,.35),
        0 2px 0 rgba(0,0,0,.32),
        0 3px 0 rgba(0,0,0,.29),
        0 4px 0 rgba(0,0,0,.26),
        0 10px 24px rgba(0,0,0,.58),
        0 0 26px rgba(120,200,255,.18),
        0 0 64px rgba(220,120,255,.14);
    }
    @media (max-width:520px){ .orbTime{font-size: 60px;} }

    .orbMode{
      margin-top: 10px;
      font-size: 14px;
      letter-spacing: .8px;
      color: rgba(255,255,255,.80);
      text-shadow: 0 10px 24px rgba(0,0,0,.45);
    }
    .orbMeta{
      margin-top: 8px;
      font-size: 12px;
      color: rgba(255,255,255,.62);
      line-height:1.5;
      text-shadow: 0 10px 24px rgba(0,0,0,.45);
    }

    .orbBtns{
      margin-top: 18px;
      display:flex;
      flex-direction:column;
      gap:10px;
      align-items:center;
      pointer-events:auto;
      user-select:none;
    }
    .orbRow{
      display:flex;
      gap:10px;
      justify-content:center;
      flex-wrap:wrap;
    }

    .exitBtn{
      position: fixed;
      top: 14px;
      right: 14px;
      z-index: 5;
      display:none;
      pointer-events:auto;
    }
    body.focusing .exitBtn{ display:block; }
    body.focusing .ui{ display:none; }
    body.focusing .musicDock{ display:none; }
  
    /* --- Time settings (durations) --- */
    .timeSettings{
      margin-top: 12px;
      width: min(560px, 92vw);
      border:1px solid var(--uiBorder);
      background: rgba(255,255,255,.045);
      backdrop-filter: blur(10px);
      box-shadow: var(--shadow);
      border-radius: 16px;
      padding: 10px 12px;
    }
    .timeSettings summary{
      cursor:pointer;
      user-select:none;
      font-weight: 950;
      color: rgba(255,255,255,.82);
      outline:none;
    }
    .timeSettings summary::-webkit-details-marker{ display:none; }
    .tsGrid{
      display:grid;
      grid-template-columns: repeat(2, minmax(0,1fr));
      gap: 10px;
      margin-top: 10px;
    }
    .tsGrid label{
      font-size:12px;
      color: rgba(255,255,255,.72);
      display:flex;
      flex-direction:column;
      gap: 6px;
    }
    .tsGrid input[type="number"]{
      width: 100%;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding: 9px 10px;
      font-weight: 900;
      outline:none;
    }
    .tsRow{
      display:flex;
      justify-content:flex-end;
      gap: 10px;
      margin-top: 10px;
    }
    .tsNote{
      margin-top: 8px;
      font-size: 12px;
      color: rgba(255,255,255,.60);
      line-height: 1.45;
    }

    .profTip{
      margin: 12px auto 10px;
      width: min(720px, 94vw);
      border:1px solid rgba(120,220,255,.25);
      background: linear-gradient(180deg, rgba(8,16,28,.55), rgba(8,16,28,.35));
      backdrop-filter: blur(12px);
      box-shadow: 0 14px 40px rgba(0,0,0,.35);
      border-radius: 18px;
      padding: 12px 14px;
      position: relative;
      overflow:hidden;
    }
    .profTip:before{
      content:'';
      position:absolute; inset:-2px;
      background:
        radial-gradient(circle at 20% 20%, rgba(140,0,255,.18), transparent 55%),
        radial-gradient(circle at 80% 30%, rgba(0,200,255,.16), transparent 55%),
        linear-gradient(90deg, rgba(0,255,240,.08), rgba(255,0,200,.06));
      filter: blur(10px);
      pointer-events:none;
    }
    .profTip:after{
      content:'';
      position:absolute; left:-30%; top:0;
      width:40%; height:100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,.12), transparent);
      transform: skewX(-20deg);
      animation: scan 3.6s linear infinite;
      opacity:.35;
      pointer-events:none;
    }
    @keyframes scan{ to{ left:120%; } }
    .ptTitle{
      position: relative;
      font-weight: 950;
      letter-spacing: .5px;
      font-size: 16px;
      text-shadow: 0 2px 0 rgba(0,0,0,.35);
      margin-bottom: 8px;
    }
    .ptBody{ position: relative; display:grid; gap:8px; }
    .ptRow{
      display:flex; align-items:flex-start; gap:10px;
      font-size: 14px;
      opacity:.92;
      line-height: 1.5;
    }
    .ptKey{
      flex:0 0 auto;
      width:18px; height:18px;
      border-radius: 6px;
      display:grid; place-items:center;
      font-weight: 950;
      font-size: 11px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.06);
      box-shadow: inset 0 0 0 1px rgba(0,255,240,.12);
    }


  
    /* ===== Focus "Poster Boy" Diamond Frame (å°ˆæ³¨è¦–è¦º) ===== */
    .focusStage{
      position: relative;
      width: min(760px, 96vw);
      height: min(520px, 70vh);
      display:flex;
      align-items:center;
      justify-content:center;
      transform: translateY(-2%);
    }
    .focusFrame{
      position: relative;
      width: min(560px, 92vw);
      padding: 34px 22px 26px;
      border-radius: 18px;
      background: rgba(10,10,18,.10);
      background-image:
        radial-gradient(circle at 18% 28%, rgba(255,255,255,.10), rgba(255,255,255,0) 48%),
        radial-gradient(circle at 82% 64%, rgba(180,150,255,.12), rgba(180,150,255,0) 54%),
        linear-gradient(180deg, rgba(20,20,40,.18), rgba(10,10,18,.08));
      box-shadow: 0 18px 60px rgba(0,0,0,.55);
      backdrop-filter: blur(6px);
    }
    .focusFrame::before,
    .focusFrame::after{
      content:'';
      position:absolute;
      left:50%;
      top:50%;
      width: 460px;
      height: 460px;
      transform: translate(-50%,-50%) rotate(45deg);
      border: 2px solid rgba(255,255,255,.16);
      box-shadow: 0 0 24px rgba(180,150,255,.18), inset 0 0 24px rgba(80,200,255,.10);
      border-radius: 22px;
      pointer-events:none;
    }
    .focusFrame::after{
      width: 520px;
      height: 520px;
      border: 1.5px solid rgba(255,255,255,.10);
      box-shadow: 0 0 34px rgba(255,140,220,.14), inset 0 0 28px rgba(255,255,255,.08);
      opacity: .95;
      animation: spinSlow 18s linear infinite;
    }
    @keyframes spinSlow{
      from{ transform: translate(-50%,-50%) rotate(45deg);}
      to{ transform: translate(-50%,-50%) rotate(405deg);}
    }

    .focusFrame .frameMarks{
      position:absolute;
      inset:0;
      pointer-events:none;
    }
    .focusFrame .frameMarks i{
      position:absolute;
      width: 12px;
      height: 12px;
      border-radius: 3px;
      background: rgba(255,255,255,.22);
      box-shadow: 0 0 18px rgba(180,150,255,.22);
      opacity:.75;
    }
    .focusFrame .frameMarks i:nth-child(1){ left: 26px; top: 26px; }
    .focusFrame .frameMarks i:nth-child(2){ right: 26px; top: 26px; }
    .focusFrame .frameMarks i:nth-child(3){ left: 26px; bottom: 26px; }
    .focusFrame .frameMarks i:nth-child(4){ right: 26px; bottom: 26px; }

    body.focusing .orbHUD{
      width: 100%;
      transform: none;
      margin: 0;
    }
    body.focusing .orbMeta{ opacity:.78; }

  </style>
</head>

<body>
  <canvas id="viz"></canvas>

  <div class="ui" id="ui">
    <div class="top">
      <div class="brand">
        <div class="dot"></div>
        <div>
          <div class="title">Vibe Pomodoro</div>
          <div class="subtitle">Spaceï¼šé–‹å§‹/æš«åœã€€Rï¼šé‡ç½®ã€€Sï¼šè·³éã€€Fï¼šé€²å…¥/é€€å‡ºå°ˆæ³¨ï¼ˆæœ‰é©šå–œï¼‰ã€€Gï¼šå…¨è¢å¹•åˆ‡æ›ï¼ˆæˆ–æŒ‰ä¸Šæ–¹ â›¶ï¼‰</div>
        </div>
      </div>

      <div class="chips">
        <div class="chip active" data-mode="focus">å°ˆæ³¨</div>
        <div class="chip" data-mode="rest">ä¼‘æ¯</div>
        <div class="chip" id="enterFocusChip">âœ¨ é€²å…¥å°ˆæ³¨</div>
        <div class="chip" id="fsChip">â›¶ å…¨è¢å¹•</div>
      </div>
    </div>

    <div class="centerTimer">
      <div class="bigTime" id="timeText">25:00</div>
      <div class="modeLine" id="modeText">å°ˆæ³¨ï¼ˆæœªé€²å…¥å°ˆæ³¨è¦–è¦ºï¼‰</div>

      <div class="profTip" id="profTip">
        <div class="ptTitle">ğŸ‘€ æ“ä½œæç¤ºï¼ˆçµ¦ç¬¬ä¸€æ¬¡ä½¿ç”¨çš„äººï¼‰</div>
        <div class="ptBody">
          <div class="ptRow"><span class="ptKey">1</span> å±•é–‹ã€Œæ™‚é–“è¨­å®šã€è¼¸å…¥<strong>å°ˆæ³¨</strong>èˆ‡<strong>ä¼‘æ¯</strong>åˆ†é˜ï¼ŒæŒ‰<strong>å¥—ç”¨</strong></div>
          <div class="ptRow"><span class="ptKey">2</span> æŒ‰<strong>é–‹å§‹</strong>é–‹å§‹å€’æ•¸ï¼›æŒ‰<strong>è·³é</strong>å¯åˆ‡åˆ°ä¸‹ä¸€æ®µ</div>
          <div class="ptRow"><span class="ptKey">3</span> æƒ³çœ‹é©šå–œï¼šå³ä¸‹è§’å…ˆ<strong>é¸æ­Œä¸¦æ’­æ”¾</strong>ï¼Œå†æŒ‰<strong>âœ¨ é€²å…¥å°ˆæ³¨</strong></div>
        </div>
      </div>

      <details class="timeSettings" id="timeSettings">
        <summary>â± æ™‚é–“è¨­å®šï¼ˆåˆ†ï¼‰</summary>
        <div class="tsGrid">
          <label>å°ˆæ³¨<input id="durFocus" type="number" min="1" max="180" step="1" /></label>
          <label>ä¼‘æ¯<input id="durRest" type="number" min="1" max="120" step="1" /></label>
        </div>
        <div class="tsRow">
          <button class="small primary" id="applyDurBtn" type="button">å¥—ç”¨</button>
        </div>
        <div class="tsNote">å»ºè­°æ“ä½œï¼šâ‘  è¨­å®šã€Œå°ˆæ³¨/ä¼‘æ¯ã€åˆ†é˜ â†’ â‘¡ æŒ‰ã€Œå¥—ç”¨ã€â†’ â‘¢ æŒ‰ã€Œé–‹å§‹ã€ã€‚<br>âœ¨ å½©è›‹ï¼šå³ä¸‹è§’å…ˆã€Œé¸æ­Œä¸¦æ’­æ”¾ã€ï¼Œå†æŒ‰ã€Œâœ¨ é€²å…¥å°ˆæ³¨ã€æœƒæœ‰ç¯€å¥åŒæ­¥çš„é©šå–œè¦–è¦ºï¼</div>
      </details>

      <div class="btns">
        <button class="primary" id="startBtn">â–¶ é–‹å§‹</button>
        <button class="small" id="skipBtn">â­ è·³é</button>
        <button class="small danger" id="resetBtn">â†º é‡ç½®</button>
      </div>
    </div>
  </div>
  <div class="focusOverlay" id="focusOverlay">
    <div class="focusStage"><div class="focusFrame" id="focusFrame"><div class="frameMarks"><i></i><i></i><i></i><i></i></div><div class="orbHUD">
      <div class="orbTime" id="orbTime">25:00</div>
      <div class="orbMode" id="orbMode">å°ˆæ³¨ä¸­</div>
      <div class="orbMeta" id="orbMeta">æç¤ºï¼šå³ä¸‹è§’å…ˆæ’­æ”¾éŸ³æ¨‚ï¼Œç•«é¢æ‰æœƒè·Ÿè‘—ç¯€å¥åŒæ­¥ã€‚</div>

      <div class="orbBtns">
        <div class="orbRow">
        <button class="primary" id="orbStartBtn">â–¶ é–‹å§‹</button>
        <button class="small" id="orbSkipBtn">â­ è·³é</button>
        <button class="small danger" id="orbResetBtn">â†º é‡ç½®</button>
      </div>
      <div class="orbRow">
        <button class="small" id="orbFsBtn">â›¶ å…¨è¢å¹•</button>
        <button class="small danger" id="exitFocusBtn">â†© é€€å‡ºå°ˆæ³¨</button>
      </div>

      </div>
    </div></div></div>
  </div>

    <div class="musicDock" id="musicDock">
    <div class="musicTitle">
      <div>ğŸ§ èƒŒæ™¯éŸ³æ¨‚ï¼ˆå…§å»ºæ­Œå–®ï¼‰</div>
      <span id="musicHint">ä¸€éµæ’­æ”¾</span>
    </div>

    <div class="playlistHint">
      âœ… çµ¦ç¬¬ä¸€æ¬¡ä½¿ç”¨çš„äººï¼š<b>é¸ä¸€é¦– â†’ æŒ‰ â–¶ æ’­æ”¾</b><br>
      âœ¨ æƒ³çœ‹é©šå–œï¼š<b>æ’­æ”¾å¾Œ</b>å†æŒ‰ä¸Šæ–¹ <b>âœ¨ é€²å…¥å°ˆæ³¨</b>ï¼ˆè¦–è¦ºæœƒè·Ÿè‘—ç¯€å¥åŒæ­¥ï¼‰
    </div>

    <div style="margin-top:10px;">
      <select id="trackSelect">
       <option value="music/lofi.mp3">ã€Šåšäººã®å°æ›²ã€‹</option>
       <option value="music/vaundy_odorigoko.mp3">è¸Šã‚Šå­ - Vaundy</option>
      </select>
    </div>

    <div class="musicRow" style="margin-top:10px;">
      <button class="small" id="prevBtn">â® ä¸Šä¸€é¦–</button>
      <button class="small primary" id="playBtn">â–¶ æ’­æ”¾</button>
      <button class="small" id="pauseBtn">â¸ æš«åœ</button>
      <button class="small" id="nextBtn">ä¸‹ä¸€é¦– â­</button>
    </div>

    <div class="musicRow">
      <button class="small" id="shuffleBtn">ğŸ”€ éš¨æ©Ÿï¼šé—œ</button>
      <button class="small" id="repeatBtn">ğŸ” é‡è¤‡ï¼šé—œ</button>
      <button class="small danger" id="stopBtn">â¹ åœæ­¢</button>
    </div>

    <div class="volRow">
      <div>éŸ³é‡</div>
      <input id="vol" type="range" min="0" max="100" step="1" />
      <div id="volText" style="width:34px;text-align:right;">20</div>
    </div>

    <div class="status" id="status">ç‹€æ…‹ï¼šå·²è¼‰å…¥å…§å»ºæ­Œå–®</div>
    <audio id="bgAudio" preload="auto" crossorigin="anonymous"></audio>
  </div>

<script>
(() => {
  const $ = (s)=>document.querySelector(s);

  // ---------- Elements ----------
  const chips = [...document.querySelectorAll('.chip[data-mode]')];
  const enterFocusChip = $('#enterFocusChip');
  const fsChip = $('#fsChip');
  const orbFsBtn = $('#orbFsBtn');

  const timeText = $('#timeText');
  const modeText = $('#modeText');

  const startBtn = $('#startBtn');
  const skipBtn = $('#skipBtn');
  const resetBtn = $('#resetBtn');

  
  // durations settings
  const durFocus = $('#durFocus');
  const durRest  = $('#durRest');
  const applyDurBtn = $('#applyDurBtn');
const exitFocusBtn = $('#exitFocusBtn');

  const orbTime = $('#orbTime');
  const orbMode = $('#orbMode');
  const orbMeta = $('#orbMeta');
  const orbStartBtn = $('#orbStartBtn');
  const orbSkipBtn = $('#orbSkipBtn');
  const orbResetBtn = $('#orbResetBtn');

  const filePicker = $('#filePicker');
  const trackSelect = $('#trackSelect');
  const addTrackBtn = $('#addTrackBtn');
  const removeTrackBtn = $('#removeTrackBtn');
  const playBtn = $('#playBtn');
  const pauseBtn = $('#pauseBtn');
  const stopBtn = $('#stopBtn');
  const prevBtn = $('#prevBtn');
  const nextBtn = $('#nextBtn');
  const shuffleBtn = $('#shuffleBtn');
  const repeatBtn = $('#repeatBtn');
  const moveUpBtn = $('#moveUpBtn');
  const moveDownBtn = $('#moveDownBtn');
  const vol = $('#vol');
  const volText = $('#volText');
  const status = $('#status');
  const bgAudio = $('#bgAudio');

  // ---------- Fullscreen helpers ----------
  async function enterFullscreen(){
    // Fullscreen must be triggered by a user gesture (click/keydown), otherwise browsers will block it.
    const el = document.documentElement; // fullscreen the whole page

    try{
      if(!document.fullscreenElement){
        if(el.requestFullscreen) await el.requestFullscreen();
        else if(el.webkitRequestFullscreen) el.webkitRequestFullscreen(); // Safari fallback
      }
    }catch(err){
      // If blocked (NotAllowedError), keep UI usable and show a hint.
      try{ status.textContent = 'âš ï¸ å…¨è¢å¹•è¢«ç€è¦½å™¨æ“‹ä¸‹ï¼šè«‹ç”¨æŒ‰éˆ•/å¿«æ·éµæ‰‹å‹•è§¸ç™¼ï¼ˆæˆ–å…ˆé»ä¸€ä¸‹é é¢å†è©¦ä¸€æ¬¡ï¼‰'; }catch{}
    }

    // Keep music ready in the same user gesture window
    initBuiltInPlaylist();
    await loadSelectedTrack();
    syncFsChip();
  }
  async function exitFullscreen(){
    try{
      if(document.fullscreenElement){
        await document.exitFullscreen();
      }
    }catch{}
    syncFsChip();
  }
  async function toggleFullscreen(){
    if(document.fullscreenElement) await exitFullscreen();
    else await enterFullscreen();
  }
  function syncFsChip(){
    const on = !!document.fullscreenElement;
    fsChip.textContent = on ? 'â›¶ é€€å‡ºå…¨è¢å¹•' : 'â›¶ å…¨è¢å¹•';
    orbFsBtn.textContent = on ? 'â›¶ é€€å‡ºå…¨è¢å¹•' : 'â›¶ å…¨è¢å¹•';
  }
  document.addEventListener('fullscreenchange', syncFsChip);
  fsChip.addEventListener('click', toggleFullscreen);
  orbFsBtn.addEventListener('click', toggleFullscreen);

  // ---------- State ----------
  const STORAGE_KEY = 'vibe_pomodoro_v2_clean';
  const defaults = {
    mode: 'focus',
    durations: { focus: 25, rest: 5 },
    autoSwitch: true,
    autoStart: false,
    sound: true,
    focusing: false,
    music: { volume: 20, lastTrackId: null, order: [], shuffle: false, repeat: 'off' },
    totalPomodoros: 0,
    daily: {}
  };

  function deepMerge(base, extra){
    for(const k in extra){
      if(extra[k] && typeof extra[k]==='object' && !Array.isArray(extra[k])){
        base[k] = deepMerge(base[k] ?? {}, extra[k]);
      } else base[k] = extra[k];
    }
    return base;
  }
  function loadState(){
    try{
      const raw = localStorage.getItem(STORAGE_KEY);
      if(!raw) return structuredClone(defaults);
      return deepMerge(structuredClone(defaults), JSON.parse(raw));
    }catch{ return structuredClone(defaults); }
  }
  function saveState(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }
  let state = loadState();

  // ---- Migration: v2 -> simplified Focus/Rest ----
  if(!state.durations) state.durations = { focus: 25, rest: 5 };
  if(state.durations.rest == null){
    state.durations.rest = state.durations.short ?? 5;
  }
  // keep storage clean (ignore old keys)
  if('short' in state.durations) delete state.durations.short;
  if('long'  in state.durations) delete state.durations.long;
  if(state.mode === 'short' || state.mode === 'long') state.mode = 'rest';

  function clampInt(v, min, max){
    v = parseInt(v, 10);
    if(!Number.isFinite(v)) v = min;
    return Math.min(max, Math.max(min, v));
  }
  function syncDurationInputs(){
    if(!durFocus || !durRest) return;
    durFocus.value = state.durations?.focus ?? 25;
    durRest.value  = state.durations?.rest  ?? 5;
  }
  syncDurationInputs();

  if(applyDurBtn){
    applyDurBtn.addEventListener('click', ()=>{
      const next = {
        focus: clampInt(durFocus.value, 1, 180),
        rest : clampInt(durRest.value, 1, 120),
      };
      state.durations = next;
      saveState();

      // è‹¥ç›®å‰æ²’åœ¨å€’æ•¸ï¼Œå°±ç«‹åˆ»æ›´æ–°é¡¯ç¤ºï¼›å€’æ•¸ä¸­å‰‡ä¸å¼·åˆ¶æ”¹æ‰ç•¶å‰æ®µè½
      if(!running){
        remainMs = getModeMs(state.mode);
      }
      render();
      // å¥—ç”¨å¾Œè‡ªå‹•æ”¶åˆã€Œæ™‚é–“è¨­å®šã€
      const ts = document.getElementById('timeSettings');
      if(ts) ts.open = false;
    });
  }


  // ---------- Timer runtime ----------
  let running = false;
  let endAt = null;
  let remainMs = getModeMs(state.mode);
  let tickHandle = null;

  function getTodayKey(){
    const d = new Date();
    return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
  }
  function getModeMs(mode){
    const min = state.durations[mode] ?? 25;
    return Math.max(1, min) * 60 * 1000;
  }
  function fmt(ms){
    const s = Math.max(0, Math.floor(ms/1000));
    const mm = String(Math.floor(s/60)).padStart(2,'0');
    const ss = String(s%60).padStart(2,'0');
    return `${mm}:${ss}`;
  }
  function setStatus(msg, kind=''){
    status.classList.remove('ok','bad');
    if(kind==='ok') status.classList.add('ok');
    if(kind==='bad') status.classList.add('bad');
    status.textContent = `ç‹€æ…‹ï¼š${msg}`;
  }

  function render(){
    syncDurationInputs();
    const msTotal = getModeMs(state.mode);
    const msLeft = running ? Math.max(0, endAt - Date.now()) : remainMs;

    timeText.textContent = fmt(msLeft);
    orbTime.textContent = fmt(msLeft);

    const labels = { focus:'å°ˆæ³¨', rest:'ä¼‘æ¯' };
    const label = labels[state.mode] ?? 'å°ˆæ³¨';

    modeText.textContent = `${label}ï¼ˆ${state.focusing ? 'å°ˆæ³¨è¦–è¦ºä¸­' : 'æœªé€²å…¥å°ˆæ³¨è¦–è¦º'}ï¼‰`;
    orbMode.textContent = `${label}ä¸­`;

    startBtn.textContent = running ? 'â¸ æš«åœ' : (remainMs < msTotal ? 'â–¶ ç¹¼çºŒ' : 'â–¶ é–‹å§‹');
    orbStartBtn.textContent = startBtn.textContent;

    chips.forEach(c => c.classList.toggle('active', c.dataset.mode === state.mode));
    document.body.classList.toggle('focusing', !!state.focusing);

    syncFsChip();
  }

  function startTimer(){
    if(running) return;
    running = true;
    endAt = Date.now() + remainMs;
    tickHandle = setInterval(tick, 250);
    render();
  }
  function stopTimer(keepRemain=true){
    if(tickHandle) clearInterval(tickHandle);
    tickHandle = null;
    if(running){
      const left = Math.max(0, endAt - Date.now());
      if(keepRemain) remainMs = left;
    }
    running = false;
    endAt = null;
    render();
  }
  function resetTimer(){
    stopTimer(false);
    remainMs = getModeMs(state.mode);
    render();
  }
  function skipSegment(){
    stopTimer(false);
    goNext(true);
  }

  function beep(){
    try{
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type = 'sine';
      o.frequency.value = 880;
      g.gain.value = 0.05;
      o.connect(g); g.connect(ctx.destination);
      o.start();
      setTimeout(()=>{ o.stop(); ctx.close(); }, 140);
    }catch{}
  }

  function incrementPomodoro(){
    state.totalPomodoros += 1;
    const key = getTodayKey();
    state.daily[key] = (state.daily[key] ?? 0) + 1;
    saveState();
  }

  function goNext(fromAuto=false){
    if(state.mode === 'focus'){
      incrementPomodoro();
      setMode('rest', {fromAuto});
      return;
    }
    setMode('focus', {fromAuto});
  }

  function tick(){
    const left = endAt - Date.now();
    if(left <= 0){
      stopTimer(false);
      remainMs = 0;
      render();
      if(state.sound) beep();
      if(state.autoSwitch) goNext(true);
      return;
    }
    render();
  }

  function setMode(mode, {fromAuto=false} = {}){
    state.mode = mode;
    saveState();
    stopTimer(false);
    remainMs = getModeMs(mode);
    render();
    if(fromAuto && state.autoStart) startTimer();
  }

  chips.forEach(c => c.addEventListener('click', ()=> setMode(c.dataset.mode) ));
  function bindStart(){ running ? stopTimer(true) : startTimer(); }
  startBtn.addEventListener('click', bindStart);
  orbStartBtn.addEventListener('click', bindStart);

  skipBtn.addEventListener('click', skipSegment);
  orbSkipBtn.addEventListener('click', skipSegment);

  resetBtn.addEventListener('click', resetTimer);
  orbResetBtn.addEventListener('click', resetTimer);

  async function enterFocus(){
    state.focusing = true;
    saveState();
    // é€²å…¥å°ˆæ³¨ä¸å†è‡ªå‹•å…¨è¢å¹•ï¼ˆæ”¹ç”±ä½¿ç”¨è€…æŒ‰ â›¶ æˆ– G è‡ªè¡Œåˆ‡æ›ï¼‰
orbMeta.textContent = (bgAudio.src && !bgAudio.paused)
      ? 'âœ¨ é©šå–œå·²å•Ÿå‹•ï¼šç•«é¢æœƒè·Ÿè‘—éŸ³æ¨‚ç¯€å¥åŒæ­¥ï¼é›¢é–‹ï¼šæŒ‰ã€Œâ†© é€€å‡ºå°ˆæ³¨ã€æˆ–æŒ‰ F'
      : 'æç¤ºï¼šå…ˆåœ¨å³ä¸‹è§’ã€Œé¸æ­Œä¸¦æ’­æ”¾ã€ï¼Œå†æŒ‰ã€Œâœ¨ é€²å…¥å°ˆæ³¨ã€æœƒæœ‰æ›´å¤§çš„é©šå–œï¼ˆç¯€å¥åŒæ­¥ï¼‰ã€‚';
    render();
  }
  function exitFocus(){
    state.focusing = false;
    saveState();
    render();
  }
  enterFocusChip.addEventListener('click', enterFocus);
  exitFocusBtn.addEventListener('click', exitFocus);

  window.addEventListener('keydown', async (e)=>{
    if(e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT')) return;
    if(e.code === 'Space'){ e.preventDefault(); bindStart(); }
    if(e.key.toLowerCase()==='r') resetTimer();
    if(e.key.toLowerCase()==='s') skipSegment();
    if(e.key.toLowerCase()==='f'){ state.focusing ? exitFocus() : enterFocus(); }
    if(e.key.toLowerCase()==='g'){ await toggleFullscreen(); }
  });

  // ---------- IndexedDB music library ----------
  const DB_NAME='vibe_mp3_db_v2';
  const DB_VER=1;
  const STORE='tracks';
  let currentObjectUrl=null;

  function openDB(){
    return new Promise((resolve,reject)=>{
      const req=indexedDB.open(DB_NAME, DB_VER);
      req.onupgradeneeded=()=>{
        const db=req.result;
        if(!db.objectStoreNames.contains(STORE)){
          db.createObjectStore(STORE,{keyPath:'id'});
        }
      };
      req.onsuccess=()=>resolve(req.result);
      req.onerror=()=>reject(req.error);
    });
  }
  async function dbPut(track){
    const db=await openDB();
    return new Promise((resolve,reject)=>{
      const tx=db.transaction(STORE,'readwrite');
      tx.objectStore(STORE).put(track);
      tx.oncomplete=()=>resolve();
      tx.onerror=()=>reject(tx.error);
    });
  }
  async function dbGetAll(){
    const db=await openDB();
    return new Promise((resolve,reject)=>{
      const tx=db.transaction(STORE,'readonly');
      const req=tx.objectStore(STORE).getAll();
      req.onsuccess=()=>resolve(req.result||[]);
      req.onerror=()=>reject(req.error);
    });
  }
  async function dbGet(id){
    const db=await openDB();
    return new Promise((resolve,reject)=>{
      const tx=db.transaction(STORE,'readonly');
      const req=tx.objectStore(STORE).get(id);
      req.onsuccess=()=>resolve(req.result||null);
      req.onerror=()=>reject(tx.error);
    });
  }
  async function dbDel(id){
    const db=await openDB();
    return new Promise((resolve,reject)=>{
      const tx=db.transaction(STORE,'readwrite');
      tx.objectStore(STORE).delete(id);
      tx.oncomplete=()=>resolve();
      tx.onerror=()=>reject(tx.error);
    });
  }

  function setAudioFromBlob(blob){
    if(currentObjectUrl) URL.revokeObjectURL(currentObjectUrl);
    currentObjectUrl = URL.createObjectURL(blob);
    bgAudio.src = currentObjectUrl;
  }

  async function refreshTracks(){
    const tracks = await dbGetAll();
    const prev = trackSelect.value || '';

    // å»ºç«‹ id -> track æ˜ å°„
    const map = new Map(tracks.map(t=>[t.id, t]));

    // æ²’æœ‰è‡ªè¨‚æ’­æ”¾é †åºæ™‚ï¼šæ²¿ç”¨åŸæœ¬ã€Œæœ€æ–°åœ¨ä¸Šã€çš„é †åº
    if(!Array.isArray(state.music.order) || state.music.order.length===0){
      const sorted = tracks.slice().sort((a,b)=>(b.addedAt||0)-(a.addedAt||0));
      state.music.order = sorted.map(t=>t.id);
      saveState();
    }else{
      // æ¸…æ‰å·²ä¸å­˜åœ¨çš„æ›²ç›®
      state.music.order = state.music.order.filter(id=>map.has(id));
      // æ–°åŠ å…¥ä½†ä¸åœ¨ order çš„æ›²ç›®ï¼šç…§åŸé‚è¼¯æ”¾åˆ°æœ€ä¸Šé¢ï¼ˆä¸ç ´å£ä½ åŸæœ¬ã€Œæ–°æ­Œåœ¨ä¸Šã€çš„ç¿’æ…£ï¼‰
      const missing = tracks
        .filter(t=>!state.music.order.includes(t.id))
        .sort((a,b)=>(b.addedAt||0)-(a.addedAt||0))
        .map(t=>t.id);
      if(missing.length){
        state.music.order = missing.concat(state.music.order);
        saveState();
      }
    }

    const ordered = state.music.order.map(id=>map.get(id)).filter(Boolean);

    trackSelect.innerHTML='';
    if(ordered.length===0){
      const opt=document.createElement('option');
      opt.value=''; opt.textContent='ï¼ˆå°šæœªåŠ å…¥éŸ³æ¨‚ï¼‰';
      trackSelect.appendChild(opt);
      return;
    }

    for(const t of ordered){
      const opt=document.createElement('option');
      opt.value=t.id;
      opt.textContent=t.name;
      trackSelect.appendChild(opt);
    }

    const wanted = state.music.lastTrackId || prev;
    if(wanted && ordered.some(x=>x.id===wanted)){
      trackSelect.value=wanted;
    }else{
      trackSelect.value=ordered[0].id;
      state.music.lastTrackId=ordered[0].id;
      saveState();
    }
  }

  async function loadSelectedTrack(){
    const src = trackSelect.value;
    const name = trackSelect.options[trackSelect.selectedIndex]?.textContent?.trim() || 'éŸ³æ¨‚';

    if(!src){
      bgAudio.removeAttribute('src');
      setStatus('å°šæœªé¸æ“‡éŸ³æ¨‚','bad');
      return;
    }
    state.music.lastTrackId = src;
    saveState();

    // å…§å»ºæ­Œå–®ï¼šç›´æ¥ä»¥ç¶²å€/ç›¸å°è·¯å¾‘è¼‰å…¥ï¼ˆé©åˆ GitHub Pagesï¼‰
    bgAudio.src = src;
    setStatus(`å·²é¸æ“‡ï¼š${name}ï¼ˆæŒ‰æ’­æ”¾å³å¯ï¼‰`,'ok');
  }

  // ---------- Playlist / Next / Prev / Shuffle / Repeat ----------
  let playQueue = null; // ä¾ç…§ shuffle/é †åºå»ºç«‹çš„æ’­æ”¾ä½‡åˆ—

  function getBaseOrder(){
    if(Array.isArray(state.music.order) && state.music.order.length){
      return state.music.order.slice();
    }
    // fallbackï¼šç”¨ç›®å‰ select çš„é †åº
    return Array.from(trackSelect.options).map(o=>o.value).filter(Boolean);
  }

  function shuffleArray(arr){
    for(let i=arr.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [arr[i],arr[j]] = [arr[j],arr[i]];
    }
    return arr;
  }

  function rebuildQueue(keepCurrent=true){
    const base = getBaseOrder().filter(Boolean);
    if(base.length===0){ playQueue = []; return; }

    if(state.music.shuffle){
      const cur = trackSelect.value || '';
      const shuffled = shuffleArray(base.slice());
      // è®“ç›®å‰é€™é¦–ä¿æŒåœ¨ç¬¬ä¸€å€‹ï¼ˆé¿å…ä½ æŒ‰ã€Œéš¨æ©Ÿã€å¾Œçªç„¶æ›æ­Œï¼‰
      if(keepCurrent && cur){
        const idx = shuffled.indexOf(cur);
        if(idx>0){
          shuffled.splice(idx,1);
          shuffled.unshift(cur);
        }
      }
      playQueue = shuffled;
    }else{
      playQueue = base;
    }
    syncMusicModeButtons();
  }

  function syncMusicModeButtons(){
    if(shuffleBtn){
      shuffleBtn.textContent = state.music.shuffle ? 'ğŸ”€ éš¨æ©Ÿï¼šé–‹' : 'ğŸ”€ éš¨æ©Ÿï¼šé—œ';
      shuffleBtn.classList.toggle('primary', !!state.music.shuffle);
    }
    if(repeatBtn){
      const r = state.music.repeat || 'off';
      const label = (r==='all') ? 'ğŸ” é‡è¤‡ï¼šé–‹' : 'ğŸ” é‡è¤‡ï¼šé—œ';
      repeatBtn.textContent = label;
      repeatBtn.classList.toggle('primary', r!=='off');
    }
  }

  async function playTrackById(id, autoPlay=true){
    if(!id) return;
    trackSelect.value = id;
    await loadSelectedTrack();
    rebuildQueue(true);

    if(!autoPlay) return;

    ensureAudioGraph();
    if(audioCtx && audioCtx.state==='suspended') await audioCtx.resume();

    try{
      await bgAudio.play();
      setStatus('æ’­æ”¾ä¸­ ğŸµï¼ˆè¦–è¦ºå·²å•Ÿå‹•ï¼‰','ok');
      if(state.focusing) orbMeta.textContent='å°ˆæ³¨æ¨¡å¼ï¼šæ™‚é–“/æŒ‰éˆ•éƒ½åœ¨çƒå…§ã€‚é›¢é–‹ï¼šæŒ‰ã€Œâ†© é€€å‡ºå°ˆæ³¨ã€æˆ–éµç›¤ Fã€‚';
    }catch{
      setStatus('æ’­æ”¾è¢«ç€è¦½å™¨æ“‹ä½ï¼šè«‹å†æŒ‰ä¸€æ¬¡æ’­æ”¾ï¼Œæˆ–å…ˆé»ä¸€ä¸‹é é¢ç©ºç™½è™•','bad');
    }
  }

  function currentQueueIndex(){
    if(!playQueue || playQueue.length===0) rebuildQueue(true);
    const id = trackSelect.value;
    return playQueue.indexOf(id);
  }

  async function gotoNext(autoPlay=true){
    const base = getBaseOrder().filter(Boolean);
    if(base.length===0){ setStatus('æ²’æœ‰å¯æ’­æ”¾çš„éŸ³æ¨‚ï¼ˆè«‹ç¢ºèªæ­Œæª”åœ¨ /music/ ä¸”è·¯å¾‘æ­£ç¢ºï¼‰','bad'); return; }

    if(!playQueue || playQueue.length===0 || (!state.music.shuffle && playQueue.length!==base.length)){
      rebuildQueue(true);
    }

    const cur = trackSelect.value;
    let idx = currentQueueIndex();
    if(idx<0){ rebuildQueue(true); idx = currentQueueIndex(); }

    const repeat = state.music.repeat || 'off';
    let nextId = null;

    if(repeat==='one'){
      nextId = cur;
    }else if(idx < playQueue.length-1){
      nextId = playQueue[idx+1];
    }else{
      // åˆ°å°¾ç«¯
      if(repeat==='all'){
        // shuffle æ¨¡å¼ä¸‹ï¼šæ¯è¼ªé‡æ´—ä¸€æ¬¡ï¼ˆæ›´åƒéŸ³æ¨‚ appï¼‰
        if(state.music.shuffle){
          rebuildQueue(false);
        }
        nextId = playQueue[0];
      }else{
        // repeat offï¼šæ’­å®Œå°±åœ
        bgAudio.pause();
        bgAudio.currentTime = 0;
        setStatus('æ’­æ”¾çµæŸï¼ˆå·²åˆ°æ¸…å–®å°¾ç«¯ï¼‰');
        return;
      }
    }

    await playTrackById(nextId, autoPlay);
  }

  async function gotoPrev(autoPlay=true){
    const base = getBaseOrder().filter(Boolean);
    if(base.length===0){ setStatus('æ²’æœ‰å¯æ’­æ”¾çš„éŸ³æ¨‚ï¼ˆè«‹ç¢ºèªæ­Œæª”åœ¨ /music/ ä¸”è·¯å¾‘æ­£ç¢ºï¼‰','bad'); return; }

    // >3 ç§’ï¼šå›åˆ°æœ¬é¦–é–‹é ­
    if(bgAudio && bgAudio.currentTime > 3){
      bgAudio.currentTime = 0;
      if(autoPlay){
        try{ await bgAudio.play(); }catch{}
      }
      return;
    }

    if(!playQueue || playQueue.length===0) rebuildQueue(true);

    const repeat = state.music.repeat || 'off';
    let idx = currentQueueIndex();
    if(idx<0){ rebuildQueue(true); idx = currentQueueIndex(); }

    let prevId = null;

    if(repeat==='one'){
      prevId = trackSelect.value;
    }else if(idx > 0){
      prevId = playQueue[idx-1];
    }else{
      // å·²åœ¨ç¬¬ä¸€é¦–
      if(repeat==='all'){
        prevId = playQueue[playQueue.length-1];
      }else{
        // repeat offï¼šå°±å›åˆ°ç¬¬ä¸€é¦–é–‹é ­
        bgAudio.currentTime = 0;
        return;
      }
    }

    await playTrackById(prevId, autoPlay);
  }

  function cycleRepeat(){
    const cur = state.music.repeat || 'off';
    state.music.repeat = (cur==='all') ? 'off' : 'all';
    saveState();
    syncMusicModeButtons();
  }

  function moveSelected(delta){
    const id = trackSelect.value;
    if(!id) return;
    if(!Array.isArray(state.music.order)) state.music.order = getBaseOrder();
    const order = state.music.order.slice();
    const idx = order.indexOf(id);
    if(idx<0) return;
    const ni = idx + delta;
    if(ni<0 || ni>=order.length) return;
    [order[idx], order[ni]] = [order[ni], order[idx]];
    state.music.order = order;
    saveState();

    refreshTracks().then(()=>{
      trackSelect.value = id;
      rebuildQueue(true);
    });
  }

  trackSelect.addEventListener('change', async ()=>{ await loadSelectedTrack(); rebuildQueue(true); });

  // ï¼ˆå…§å»ºæ­Œå–®ç‰ˆæœ¬ï¼‰ä¸æä¾›æœ¬æ©ŸåŠ å…¥/ç§»é™¤åŠŸèƒ½ï¼Œé¿å…æ•™æˆæ“ä½œå¤ªè¤‡é›œã€‚
  function syncVol(){
    vol.value = String(state.music.volume ?? 20);
    volText.textContent = String(state.music.volume ?? 20);
    bgAudio.volume = (state.music.volume ?? 20)/100;
  }
  vol.addEventListener('input', ()=>{
    const v = Number(vol.value);
    state.music.volume = v;
    saveState();
    syncVol();
    syncMusicModeButtons();
    rebuildQueue(true);
  });

  // ---------- WebAudio analyser ----------
  let audioCtx=null;
  let analyser=null;
  let srcNode=null;
  let freqData=null;
  let timeData=null;

  function ensureAudioGraph(){
    if(audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    srcNode = audioCtx.createMediaElementSource(bgAudio);
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 1024;
    analyser.smoothingTimeConstant = 0.88;
    srcNode.connect(analyser);
    analyser.connect(audioCtx.destination);
    freqData = new Uint8Array(analyser.frequencyBinCount);
    timeData = new Uint8Array(analyser.fftSize);
      buildEQMap && buildEQMap();
  }

  function getEnergy(){
    if(!analyser || !freqData) return {E:0, low:0, mid:0, hi:0};
    analyser.getByteFrequencyData(freqData);

    const n = freqData.length;
    const lowEnd = Math.floor(n*0.12);
    const midEnd = Math.floor(n*0.36);
    const hiEnd  = Math.floor(n*0.60);

    let low=0, mid=0, hi=0, all=0;
    for(let i=0;i<n;i++){
      const v = freqData[i]/255;
      all += v;
      if(i<lowEnd) low += v;
      else if(i<midEnd) mid += v;
      else if(i<hiEnd) hi += v;
    }
    all /= n;
    low /= Math.max(1, lowEnd);
    mid /= Math.max(1, midEnd-lowEnd);
    hi  /= Math.max(1, hiEnd-midEnd);

    const E = Math.min(1, low*1.5 + mid*0.75 + all*0.30);
    return {E, low, mid, hi};
  }

  playBtn.addEventListener('click', async ()=>{
    if(!bgAudio.src) await loadSelectedTrack();
    if(!bgAudio.src){ setStatus('æ²’æœ‰å¯æ’­æ”¾çš„éŸ³æ¨‚ï¼ˆè«‹ç¢ºèªæ­Œæª”åœ¨ /music/ ä¸”è·¯å¾‘æ­£ç¢ºï¼‰','bad'); return; }

    ensureAudioGraph();
    if(audioCtx.state==='suspended') await audioCtx.resume();

    try{
      await bgAudio.play();
      setStatus('æ’­æ”¾ä¸­ ğŸµï¼ˆè¦–è¦ºå·²å•Ÿå‹•ï¼‰','ok');
      if(state.focusing) orbMeta.textContent='å°ˆæ³¨æ¨¡å¼ï¼šæ™‚é–“/æŒ‰éˆ•éƒ½åœ¨çƒå…§ã€‚é›¢é–‹ï¼šæŒ‰ã€Œâ†© é€€å‡ºå°ˆæ³¨ã€æˆ–éµç›¤ Fã€‚';
    }catch{
      setStatus('æ’­æ”¾è¢«ç€è¦½å™¨æ“‹ä½ï¼šè«‹å†æŒ‰ä¸€æ¬¡æ’­æ”¾ï¼Œæˆ–å…ˆé»ä¸€ä¸‹é é¢ç©ºç™½è™•','bad');
    }
  });

  pauseBtn.addEventListener('click', ()=>{ bgAudio.pause(); setStatus('å·²æš«åœ'); });
  stopBtn.addEventListener('click', ()=>{ bgAudio.pause(); bgAudio.currentTime=0; setStatus('å·²åœæ­¢'); });

  // Playlist controls
  if(prevBtn) prevBtn.addEventListener('click', ()=>gotoPrev(true));
  if(nextBtn) nextBtn.addEventListener('click', ()=>gotoNext(true));
  if(shuffleBtn) shuffleBtn.addEventListener('click', ()=>{
    state.music.shuffle = !state.music.shuffle;
    saveState();
    rebuildQueue(true);
  });
  if(repeatBtn) repeatBtn.addEventListener('click', cycleRepeat);
  if(moveUpBtn) moveUpBtn.addEventListener('click', ()=>moveSelected(-1));
  if(moveDownBtn) moveDownBtn.addEventListener('click', ()=>moveSelected(+1));

  // è‡ªå‹•æ’­ä¸‹ä¸€é¦–
  bgAudio.addEventListener('ended', ()=>{ gotoNext(true); });


  // ---------- Visualizer ----------
  const canvas = $('#viz');
  const ctx = canvas.getContext('2d', { alpha:true });

  let DPR = 1;
  let W=0, H=0;

  function chooseDPR(){
    // 4K/é«˜ç•«è³ªï¼šç›´æ¥ä½¿ç”¨è£ç½® DPRï¼ˆä¸é™è§£æåº¦ï¼‰
    const device = window.devicePixelRatio || 1;
    return device;
  }

  // ===== å¯èª¿åƒæ•¸ =====
  const NEBULA_ALPHA = 0.75;
  const NEBULA_DRIFT = 12;
  const METEOR_RATE  = 0.010;
  const METEOR_SPEED = 1400;
  const METEOR_LEN   = 420;

  // âœ… ç«ç®­å¯èª¿
  const ROCKET_ON = true;
  const ROCKET_SPEED = 1.0;          // è¶Šå¤§è¶Šå¿«
  const ROCKET_TRAIL_TTL = 1.15;     // å°¾è·¡ä¿ç•™ç§’æ•¸
  const ROCKET_ALPHA = 0.98;         // æ•´é«”é€æ˜åº¦
  // ====================

  // ---------- Nebula (offscreen pre-render) ----------
  const nebCanvas = document.createElement('canvas');
  const nebCtx = nebCanvas.getContext('2d');

  function buildNebula(){
    nebCanvas.width  = Math.floor(W * 1.25);
    nebCanvas.height = Math.floor(H * 1.25);

    nebCtx.clearRect(0,0,nebCanvas.width, nebCanvas.height);

    nebCtx.globalCompositeOperation = 'source-over';
    nebCtx.filter = `blur(${22*DPR}px)`;

    const blobs = 28;
    for(let i=0;i<blobs;i++){
      const x = Math.random()*nebCanvas.width;
      const y = Math.random()*nebCanvas.height;
      const r = (220 + Math.random()*520) * DPR;

      const hue = (Math.random() < 0.55) ? (270 + Math.random()*40) : (200 + Math.random()*35);
      const a0 = 0.06 + Math.random()*0.08;

      const g = nebCtx.createRadialGradient(x,y,0, x,y,r);
      g.addColorStop(0.0, `hsla(${hue},100%,70%,${a0})`);
      g.addColorStop(0.4, `hsla(${hue+12},100%,68%,${a0*0.55})`);
      g.addColorStop(1.0, `rgba(0,0,0,0)`);
      nebCtx.fillStyle = g;
      nebCtx.beginPath();
      nebCtx.arc(x,y,r,0,Math.PI*2);
      nebCtx.fill();
    }

    nebCtx.filter = `blur(${14*DPR}px)`;
    const mist = 46;
    for(let i=0;i<mist;i++){
      const x = Math.random()*nebCanvas.width;
      const y = Math.random()*nebCanvas.height;
      const r = (120 + Math.random()*260) * DPR;

      const hue = (Math.random() < 0.5) ? (295 + Math.random()*25) : (205 + Math.random()*25);
      const a0 = 0.035 + Math.random()*0.05;

      const g = nebCtx.createRadialGradient(x,y,0, x,y,r);
      g.addColorStop(0.0, `hsla(${hue},100%,72%,${a0})`);
      g.addColorStop(0.55, `hsla(${hue},100%,70%,${a0*0.35})`);
      g.addColorStop(1.0, `rgba(0,0,0,0)`);
      nebCtx.fillStyle = g;
      nebCtx.beginPath();
      nebCtx.arc(x,y,r,0,Math.PI*2);
      nebCtx.fill();
    }

    nebCtx.filter = 'none';
  }

  let nebE = 0;

  function drawNebula(t, E){
    // âœ… æ›´èˆ’æœçš„å±¤æ¬¡é–ƒçˆï¼šæ”¾å¤§ä¸€é»ã€ä½†ç”¨å¹³æ»‘èƒ½é‡é¿å…ã€Œçœ¨çœ¼ã€æ„Ÿ
    nebE = nebE*0.93 + E*0.07;
    const pulse = Math.pow(Math.min(1, nebE*1.25), 1.6);

    const ox = Math.sin(t*0.03) * NEBULA_DRIFT * DPR;
    const oy = Math.cos(t*0.025) * NEBULA_DRIFT * DPR;

    const alphaBase = Math.min(1, NEBULA_ALPHA * (0.60 + pulse*0.70));

    // è¼•å¾®å‘¼å¸ + èƒ½é‡æ”¾å¤§ï¼ˆæ›´æœ‰å±¤æ¬¡æ„Ÿï¼‰
    const s1 = 1.00 + 0.010*Math.sin(t*0.10) + pulse*0.025;
    const s2 = 1.05 + 0.012*Math.sin(t*0.07+1.3) + pulse*0.045;

    ctx.save();
    ctx.globalCompositeOperation = 'screen';

    // base layer
    ctx.globalAlpha = alphaBase;
    drawCentered(nebCanvas, -ox, -oy, s1);

    // bigger/softer glow layer
    ctx.globalAlpha = alphaBase * 0.45;
    drawCentered(nebCanvas, ox*0.6, oy*0.6, s2);

    // very soft radial bloom (adds depth, not blink)
    const r = Math.min(W,H) * (0.20 + pulse*0.22);
    const g = ctx.createRadialGradient(W*0.5, H*0.45, 0, W*0.5, H*0.45, r);
    g.addColorStop(0.0, `rgba(180,140,255,${0.06 + pulse*0.10})`);
    g.addColorStop(0.50, `rgba(120,200,255,${0.03 + pulse*0.08})`);
    g.addColorStop(1.0, `rgba(0,0,0,0)`);
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    ctx.restore();
  }

  function drawCentered(img, dx, dy, scale){
    const w = img.width  * scale;
    const h = img.height * scale;
    const x = (W - w) * 0.5 + dx;
    const y = (H - h) * 0.5 + dy;
    ctx.drawImage(img, x, y, w, h);
  }

  // ---------- Stars (MOVE, NO TRAIL) ----------
  let stars = [];
  function initStars(){
    const count = Math.floor((Math.min(window.innerWidth, window.innerHeight) < 700) ? 150 : 240);
    stars = [];
    for(let i=0;i<count;i++){
      const x = Math.random()*W;
      const y = Math.random()*H;

      const big = Math.random() < 0.10; // âœ… è®“æ˜Ÿæ˜Ÿã€Œæœ‰å¤§æœ‰å°ã€
      const r = (big ? (1.6 + Math.random()*2.8) : (0.70 + Math.random()*1.90)) * DPR;

      const vy = (0.10 + Math.random()*0.55) * DPR;
      const vx = (-0.08 + Math.random()*0.16) * DPR;

      stars.push({
        x, y, r, big,
        glow: big ? (18 + Math.random()*34) * DPR : 0,
        a: (big ? 0.18 : 0.12) + Math.random()*0.55,
        tw: Math.random()*Math.PI*2,
        sp: 0.32 + Math.random()*0.95,
        vx, vy,
        driftAmp: (0.20 + Math.random()*0.90) * DPR,
        driftSpd: 0.18 + Math.random()*0.52,
        seed: Math.random()*Math.PI*2
      });
    }
  }

  function drawStars(timeSec, E){
    ctx.save();
    ctx.globalCompositeOperation='screen';

    for(const s of stars){
      const drift = Math.sin(timeSec*s.driftSpd + s.seed) * s.driftAmp;
      s.x += s.vx + drift*0.002;
      s.y += s.vy * (0.85 + E*0.35);

      if(s.y > H + 10*DPR){ s.y = -10*DPR; s.x = Math.random()*W; }
      if(s.x < -12*DPR) s.x = W + 12*DPR;
      if(s.x > W + 12*DPR) s.x = -12*DPR;

      s.tw += 0.012*s.sp;
      const tw = 0.55 + 0.45*Math.sin(s.tw + timeSec*0.8);
      let a = s.a * tw * (0.75 + E*0.28);
      if(s.big) a *= (1.08 + 0.10*Math.sin(timeSec*1.2 + s.seed));

      // âœ… å¤§æ˜Ÿæ˜Ÿï¼šå¸¶æŸ”å…‰ï¼ˆæ›´ã€Œé¡¯çœ¼ã€ä½†ä¸åˆºçœ¼ï¼‰
      if(s.big){
        const g = ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, s.glow);
        g.addColorStop(0.0, `rgba(255,255,255,${a*0.85})`);
        g.addColorStop(0.35, `rgba(200,230,255,${a*0.22})`);
        g.addColorStop(1.0, 'rgba(0,0,0,0)');
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.glow, 0, Math.PI*2);
        ctx.fill();
      }

      // æ ¸å¿ƒæ˜Ÿé»
      ctx.fillStyle = `rgba(255,255,255,${a})`;
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
      ctx.fill();
    }

    ctx.restore();
  }
// ---------- Meteors (DOWN-RIGHT âœ…) ----------
  const meteors = [];
  function spawnMeteor(){
    const startX = W * (-0.10 + Math.random()*0.45);
    const startY = H * (Math.random()*0.35);

    const angle = (Math.PI * (35 + Math.random()*20)) / 180;
    const speed = (METEOR_SPEED * (0.75 + Math.random()*0.65)) * DPR;

    const vx = Math.cos(angle) * speed;
    const vy = Math.sin(angle) * speed;

    const life = 0.55 + Math.random()*0.65;
    meteors.push({
      x: startX, y: startY,
      vx, vy,
      t: 0,
      life,
      len: (METEOR_LEN * (0.7 + Math.random()*0.7)) * DPR,
      width: (1.6 + Math.random()*2.2) * DPR,
      hue: (Math.random()<0.5) ? 205 : 290
    });
  }

  function updateAndDrawMeteors(dt, E){
    const p = METEOR_RATE * (0.85 + E*0.55);
    if(Math.random() < p) spawnMeteor();

    ctx.save();
    ctx.globalCompositeOperation = 'screen';

    for(let i=meteors.length-1;i>=0;i--){
      const m = meteors[i];
      m.t += dt;
      m.x += m.vx * dt;
      m.y += m.vy * dt;

      const k = Math.min(1, m.t / m.life);
      const fadeIn  = Math.min(1, k*3.0);
      const fadeOut = Math.min(1, (1-k)*2.4);
      const a = Math.max(0, Math.min(1, fadeIn * fadeOut)) * (0.65 + E*0.35);

      const hx = m.x, hy = m.y;

      const vlen = Math.hypot(m.vx, m.vy) || 1;
      const nx = m.vx / vlen;
      const ny = m.vy / vlen;

      const tx = hx - nx * m.len;
      const ty = hy - ny * m.len;

      const g = ctx.createLinearGradient(tx,ty,hx,hy);
      g.addColorStop(0.0, `hsla(${m.hue},100%,72%,0)`);
      g.addColorStop(0.25, `hsla(${m.hue},100%,72%,${a*0.22})`);
      g.addColorStop(1.0, `hsla(${m.hue},100%,75%,${a})`);

      ctx.strokeStyle = g;
      ctx.lineWidth = m.width;
      ctx.lineCap = 'round';
      ctx.shadowBlur = (10 + E*12) * DPR;
      ctx.shadowColor = `hsla(${m.hue},100%,75%,${a*0.8})`;

      ctx.beginPath();
      ctx.moveTo(tx,ty);
      ctx.lineTo(hx,hy);
      ctx.stroke();

      ctx.shadowBlur = 0;
      ctx.fillStyle = `rgba(255,255,255,${a})`;
      ctx.beginPath();
      ctx.arc(hx,hy, (1.2 + E*1.6)*DPR, 0, Math.PI*2);
      ctx.fill();

      if(m.t > m.life || m.x > W + m.len || m.y > H + m.len){
        meteors.splice(i,1);
      }
    }

    ctx.restore();
  }

  // =========================================================
  // âœ… Cute Rocket â€” Smooth Zigzag Flight (Top-Left -> Bottom-Right)
  //    - æ¯ä¸€åœˆéƒ½æœƒé‡æ–°éš¨æ©Ÿç”Ÿæˆä¸€æ¢ã€Œé †æ»‘ã€çš„æ›²ç·šè·¯å¾‘
  //    - å¾å³ä¸‹è§’å‡ºç•Œæ¶ˆå¤±ï¼Œåœä¸€ä¸‹ï¼Œå†å¾å·¦ä¸Šè§’é‡æ–°é€²å ´
  // =========================================================
  const rocketTrail = []; // {x,y,t}

  // âœ… ç«ç®­å¯èª¿ï¼ˆä¿ç•™ä½ åŸæœ¬çš„é–‹é—œ/é€Ÿåº¦/å°¾è·¡åƒæ•¸ï¼‰
  const ROCKET_ROUTE = {
    fly: 7.2,    // åœ¨ç•«é¢ä¸­é£›è¡Œç§’æ•¸ï¼ˆè¶Šå¤§è¶Šæ…¢ï¼‰
    pause: 0.9,  // å‡ºç•Œå¾Œæ¶ˆå¤±ç§’æ•¸
    tension: 1.0 // Catmull-Rom è½‰ Bezier çš„å¼µåŠ›ï¼ˆ0.8~1.2 éƒ½å¥½çœ‹ï¼‰
  };

  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function lerp(a,b,t){ return a + (b-a)*t; }
  function easeInOut(t){
    t = clamp(t,0,1);
    return t<0.5 ? 2*t*t : 1 - Math.pow(-2*t+2,2)/2;
  }

  function add(p,q){ return {x:p.x+q.x, y:p.y+q.y}; }
  function sub(p,q){ return {x:p.x-q.x, y:p.y-q.y}; }
  function mul(p,s){ return {x:p.x*s, y:p.y*s}; }
  function len(p){ return Math.hypot(p.x,p.y) || 1; }
  function norm(p){ const l=len(p); return {x:p.x/l, y:p.y/l}; }

  function bezier(p0,p1,p2,p3,u){
    const omt = 1-u;
    const omt2 = omt*omt, u2=u*u;
    return {
      x: (omt2*omt)*p0.x + 3*(omt2*u)*p1.x + 3*(omt*u2)*p2.x + (u2*u)*p3.x,
      y: (omt2*omt)*p0.y + 3*(omt2*u)*p1.y + 3*(omt*u2)*p2.y + (u2*u)*p3.y
    };
  }
  function bezierD(p0,p1,p2,p3,u){
    const omt=1-u;
    return {
      x: 3*omt*omt*(p1.x-p0.x) + 6*omt*u*(p2.x-p1.x) + 3*u*u*(p3.x-p2.x),
      y: 3*omt*omt*(p1.y-p0.y) + 6*omt*u*(p2.y-p1.y) + 3*u*u*(p3.y-p2.y)
    };
  }

  // Catmull-Rom -> Bezierï¼ˆè®“è·¯å¾‘ã€Œè½‰å½ä¹Ÿå¾ˆé †ã€ï¼‰
  function catmullToBezier(p0,p1,p2,p3, tension=1){
    // segment: p1 -> p2
    const c1 = add(p1, mul(sub(p2,p0), (tension/6)));
    const c2 = sub(p2, mul(sub(p3,p1), (tension/6)));
    return {p0:p1, p1:c1, p2:c2, p3:p2};
  }

  function approxSegLen(seg){
    // ç²—ä¼°é•·åº¦ï¼ˆç”¨ä¾†åˆ†é…æ™‚é–“ï¼Œè®“é€Ÿåº¦æ›´å‡å‹»ï¼‰
    let L=0;
    let prev = bezier(seg.p0,seg.p1,seg.p2,seg.p3,0);
    const N=14;
    for(let i=1;i<=N;i++){
      const u=i/N;
      const cur = bezier(seg.p0,seg.p1,seg.p2,seg.p3,u);
      L += Math.hypot(cur.x-prev.x, cur.y-prev.y);
      prev = cur;
    }
    return L;
  }

  // æ¯ä¸€åœˆçš„é£›è¡Œè·¯å¾‘ï¼ˆæœƒé‡å»ºï¼‰
  let rocketRoute = null;
  let routeAnchor = 0; // ç§’æ•¸åŸºæº–ï¼šç”¨ä¾†åœ¨ã€Œæ¯ä¸€åœˆã€åˆ‡æ›æ™‚é‡ç”Ÿè·¯å¾‘

  function rand(a,b){ return a + Math.random()*(b-a); }

  function buildRocketRoute(){
    const margin = 0.22*Math.min(W,H);

    // å›ºå®šï¼šå·¦ä¸Šé€²ã€å³ä¸‹å‡ºï¼ˆç¬¦åˆä½ èªªçš„ã€Œå³ä¸‹è§’å‡ºå» / å·¦ä¸Šè§’å‡ºä¾†ã€ï¼‰
    const start = {x: -margin, y: -margin};
    const end   = {x: W + margin, y: H + margin};

    // å…©å€‹è·¯å¾‘æ§åˆ¶é»ï¼šç”¨ä¾†åšã€Œå°å°æ›²æŠ˜ / æ–œç·šè½‰å½ã€
    const k1 = { x: W*rand(0.18,0.40), y: H*rand(0.10,0.48) };
    const k2 = { x: W*rand(0.55,0.86), y: H*rand(0.42,0.82) };

    // å…©ç«¯çš„ ghost pointsï¼ˆè®“èµ·é»/çµ‚é»ä¹Ÿé †ï¼‰
    const g0 = add(start, sub(start, k1)); // start å»¶ä¼¸
    const g3 = add(end,   sub(end,   k2)); // end å»¶ä¼¸

    const s0 = catmullToBezier(g0, start, k1, k2, ROCKET_ROUTE.tension);
    const s1 = catmullToBezier(start, k1, k2, end, ROCKET_ROUTE.tension);
    const s2 = catmullToBezier(k1, k2, end, g3, ROCKET_ROUTE.tension);

    const segs = [s0,s1,s2];

    // æ™‚é–“åˆ†é…ï¼ˆä¾é•·åº¦æ¯”ä¾‹ï¼‰
    const lens = segs.map(approxSegLen);
    const total = lens.reduce((a,b)=>a+b,0) || 1;
    const fly = ROCKET_ROUTE.fly;
    const durs = lens.map(L => fly*(L/total));

    rocketRoute = { start, end, k1, k2, segs, durs, fly, pause: ROCKET_ROUTE.pause };
  }

  function addRocketTrail(x,y,t){
    rocketTrail.push({x,y,t});
    const cutoff = t - ROCKET_TRAIL_TTL;
    while(rocketTrail.length && rocketTrail[0].t < cutoff) rocketTrail.shift();
  }

  function drawRocketTrail(t, E){
    if(rocketTrail.length < 2) return;
    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    ctx.lineCap='round';
    ctx.lineJoin='round';

    for(let i=1;i<rocketTrail.length;i++){
      const a = rocketTrail[i-1], b = rocketTrail[i];
      const age = t - b.t;
      const alpha = clamp(1 - age/ROCKET_TRAIL_TTL, 0, 1);

      const w = (10*DPR) * (0.10 + 0.90*alpha);
      const g = ctx.createLinearGradient(a.x,a.y, b.x,b.y);
      g.addColorStop(0.0, `rgba(255,160,220,0)`);
      g.addColorStop(0.35, `rgba(210,170,255,${0.22*alpha})`);
      g.addColorStop(1.0, `rgba(140,220,255,${(0.52+E*0.18)*alpha})`);

      ctx.strokeStyle = g;
      ctx.lineWidth = w;
      ctx.beginPath();
      ctx.moveTo(a.x,a.y);
      ctx.lineTo(b.x,b.y);
      ctx.stroke();
    }

    ctx.restore();
  }

  
  function drawCuteRocket(x,y,rot, t, E){
    // ğŸ›¸ UFOï¼ˆåƒè€ƒä½ çµ¦çš„å¯æ„›å¤ªç©ºå¹½æµ®é¢¨æ ¼ï¼‰ï¼šå¤–è§€æ›´åƒã€Œç´«è—æ˜Ÿé›²é£›ç¢Ÿï¼‹ç»ç’ƒç½©å°å¤–æ˜Ÿäººã€
    const base = Math.min(W,H)/1100;
    const s = (0.92 + 0.06*Math.sin(t*1.1)) * base;

    ctx.save();
    ctx.translate(x,y);
    ctx.rotate(rot);
    ctx.scale(s, s);

    const pulse = 0.5 + 0.5*Math.sin(t*1.6);

    // ----- soft halo glow -----
    ctx.globalCompositeOperation = 'screen';
    const halo = ctx.createRadialGradient(0, 18, 30, 0, 18, 170);
    halo.addColorStop(0, `rgba(170,130,255,${0.18+E*0.12})`);
    halo.addColorStop(0.55, `rgba(120,220,255,${0.10+E*0.08})`);
    halo.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = halo;
    ctx.beginPath();
    ctx.ellipse(0, 22, 160, 78, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.globalCompositeOperation = 'source-over';

    // ----- saucer body (galaxy gradient) -----
    const bodyGrad = ctx.createLinearGradient(-140, -30, 140, 70);
    bodyGrad.addColorStop(0.00,'rgba(110,70,210,0.98)');
    bodyGrad.addColorStop(0.38,'rgba(80,200,255,0.90)');
    bodyGrad.addColorStop(0.70,'rgba(210,120,255,0.92)');
    bodyGrad.addColorStop(1.00,'rgba(80,55,185,0.98)');
    ctx.fillStyle = bodyGrad;
    ctx.strokeStyle = 'rgba(255,255,255,0.35)';
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.ellipse(0, 18, 122, 44, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.stroke();

    // Rim highlight
    ctx.strokeStyle = `rgba(255,255,255,${0.22+E*0.10})`;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.ellipse(0, 12, 100, 30, 0, 0, Math.PI*2);
    ctx.stroke();

    // Underside glow
    const under = ctx.createRadialGradient(0, 42, 10, 0, 50, 110);
    under.addColorStop(0, `rgba(120,220,255,${0.26+E*0.14})`);
    under.addColorStop(1, 'rgba(70,40,150,0)');
    ctx.fillStyle = under;
    ctx.beginPath();
    ctx.ellipse(0, 48, 86, 28, 0, 0, Math.PI*2);
    ctx.fill();

    // Tiny star speckles on body (å›ºå®šé»ï¼Œä¸äº‚è·³)
    ctx.fillStyle = `rgba(255,255,255,${0.30+E*0.18})`;
    const stars = [
      [-78, 22, 1.3], [-54,  8, 2.0], [-24, 14, 1.4], [  4,  6, 1.6],
      [ 32, 14, 1.3], [ 62, 26, 2.0], [ 74, 10, 1.2], [-10, 30, 1.2]
    ];
    for(const [sx,sy,r] of stars){
      ctx.beginPath();
      ctx.arc(sx, sy, r*(1+0.18*pulse), 0, Math.PI*2);
      ctx.fill();
    }
    // äº®ä¸€é¡†åå­—æ˜Ÿ
    ctx.strokeStyle = `rgba(255,255,255,${0.35+E*0.15})`;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, 6); ctx.lineTo(0, 16);
    ctx.moveTo(-6, 11); ctx.lineTo(6, 11);
    ctx.stroke();

    // ----- portholes (galaxy windows) -----
    const holes = [[-78,18],[-42,30],[0,34],[42,30],[78,18]];
    for(const [hx,hy] of holes){
      ctx.save();
      ctx.translate(hx, hy);

      // outer ring
      ctx.fillStyle = 'rgba(170,160,245,0.85)';
      ctx.strokeStyle = 'rgba(255,255,255,0.45)';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(0,0,16,0,Math.PI*2);
      ctx.fill(); ctx.stroke();

      // inner "galaxy"
      const g = ctx.createRadialGradient(-4,-4,2, 0,0,13);
      g.addColorStop(0, 'rgba(255,210,255,0.95)');
      g.addColorStop(0.45,'rgba(120,220,255,0.90)');
      g.addColorStop(1, 'rgba(70,50,150,0.95)');
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(0,0,11,0,Math.PI*2);
      ctx.fill();

      // sparkle
      ctx.fillStyle = 'rgba(255,255,255,0.85)';
      ctx.beginPath();
      ctx.arc(4,-3,1.7,0,Math.PI*2);
      ctx.fill();

      ctx.restore();
    }

    // ----- dome (glass) -----
    const domeGrad = ctx.createRadialGradient(0,-22, 10, 0,-34, 82);
    domeGrad.addColorStop(0, `rgba(255,255,255,${0.62+E*0.10})`);
    domeGrad.addColorStop(0.55, `rgba(140,220,255,${0.20+E*0.10})`);
    domeGrad.addColorStop(1, 'rgba(120,160,255,0.04)');
    ctx.fillStyle = domeGrad;
    ctx.strokeStyle = 'rgba(255,255,255,0.30)';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.ellipse(0, -6, 58, 42, 0, Math.PI, 0, true);
    ctx.closePath();
    ctx.fill(); ctx.stroke();

    // Dome highlight
    ctx.strokeStyle = `rgba(255,255,255,${0.20+E*0.08})`;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.ellipse(-16, -18, 14, 10, -0.2, 0, Math.PI*2);
    ctx.stroke();

    // ----- cute alien inside -----
    ctx.save();
    ctx.translate(0, -18);

    // head
    const headGrad = ctx.createRadialGradient(-10,-10,6, 0,0,32);
    headGrad.addColorStop(0,'rgba(170,255,255,0.98)');
    headGrad.addColorStop(1,'rgba(90,200,255,0.98)');
    ctx.fillStyle = headGrad;
    ctx.strokeStyle = 'rgba(255,255,255,0.35)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(0,0,22,0,Math.PI*2);
    ctx.fill(); ctx.stroke();

    // eyes
    function eye(ex){
      const eg = ctx.createRadialGradient(ex-2,-2,1, ex,0,10);
      eg.addColorStop(0,'rgba(255,255,255,1)');
      eg.addColorStop(1,'rgba(35,45,90,1)');
      ctx.fillStyle = eg;
      ctx.beginPath();
      ctx.ellipse(ex,-2,8,10,0,0,Math.PI*2);
      ctx.fill();
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.beginPath();
      ctx.arc(ex-2,-6,2.2,0,Math.PI*2);
      ctx.fill();
    }
    eye(-8); eye(8);

    // smile
    ctx.strokeStyle = 'rgba(30,60,90,0.65)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(0,6,6,0,Math.PI);
    ctx.stroke();

    // suit body (rounded rect)
    ctx.translate(0, 28);
    const suitGrad = ctx.createLinearGradient(-16,-12,16,22);
    suitGrad.addColorStop(0,'rgba(200,150,255,0.95)');
    suitGrad.addColorStop(1,'rgba(120,120,255,0.95)');
    ctx.fillStyle = suitGrad;
    ctx.strokeStyle = 'rgba(255,255,255,0.25)';
    ctx.lineWidth = 2;
    const x0=-14,y0=-12,w=28,h=30,r=9;
    ctx.beginPath();
    ctx.moveTo(x0+r,y0);
    ctx.arcTo(x0+w,y0,x0+w,y0+h,r);
    ctx.arcTo(x0+w,y0+h,x0,y0+h,r);
    ctx.arcTo(x0,y0+h,x0,y0,r);
    ctx.arcTo(x0,y0,x0+w,y0,r);
    ctx.closePath();
    ctx.fill(); ctx.stroke();

    // wave hand
    ctx.strokeStyle = 'rgba(210,170,255,0.92)';
    ctx.lineWidth = 4;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(14,-6);
    ctx.lineTo(28,-18);
    ctx.stroke();
    ctx.fillStyle = 'rgba(180,255,255,0.95)';
    ctx.beginPath();
    ctx.arc(30,-20,6,0,Math.PI*2);
    ctx.fill();

    ctx.restore(); // alien

    // ----- subtle tractor beam -----
    const beam = ctx.createLinearGradient(0, 58, 0, 180);
    beam.addColorStop(0, 'rgba(120,220,255,0)');
    beam.addColorStop(0.18, `rgba(180,255,255,${0.11+E*0.10})`);
    beam.addColorStop(1, 'rgba(120,220,255,0)');
    ctx.fillStyle = beam;
    ctx.beginPath();
    ctx.moveTo(-34, 58);
    ctx.lineTo( 34, 58);
    ctx.lineTo( 60, 180);
    ctx.lineTo(-60, 180);
    ctx.closePath();
    ctx.fill();

    ctx.restore();
  }


  function getRocketPose(t, E){
    if(!rocketRoute) buildRocketRoute();

    const total = rocketRoute.fly + rocketRoute.pause;
    const local = (t*ROCKET_SPEED) % total;

    // âœ… æ¯åœˆé–‹å§‹æ™‚é‡ç”Ÿè·¯å¾‘ï¼ˆè®“ã€Œéš¨æ©Ÿã€ä½†ä¸æŠ–ï¼‰
    const loops = Math.floor((t*ROCKET_SPEED) / total);
    if(loops !== routeAnchor){
      routeAnchor = loops;
      buildRocketRoute();
      // æ¸…æ‰å°¾è·¡ï¼Œé¿å…ä¸Šä¸€åœˆæ®˜ç•™é»åœ¨è§’è½ï¼ˆæ›´ä¹¾æ·¨ï¼‰
      rocketTrail.length = 0;
    }

    if(local >= rocketRoute.fly){
      return {x:-9999, y:-9999, dx:1, dy:0, visible:false};
    }

    // æ‰¾ç›®å‰è½åœ¨å“ªå€‹ segment
    let acc = 0;
    let segIdx = 0;
    for(let i=0;i<rocketRoute.durs.length;i++){
      if(local < acc + rocketRoute.durs[i]){ segIdx=i; break; }
      acc += rocketRoute.durs[i];
    }
    const seg = rocketRoute.segs[segIdx];
    const segT = (local - acc) / rocketRoute.durs[segIdx];
    const u = easeInOut(segT);

    let pos = bezier(seg.p0,seg.p1,seg.p2,seg.p3,u);
    let d   = bezierD(seg.p0,seg.p1,seg.p2,seg.p3,u);

    // âœ… å°å°ã€Œé£„ã€çš„è½‰æŠ˜ï¼ˆè®“è·¯å¾‘æ›´è‡ªç„¶ï¼Œä½†ä¸æŠ–ï¼‰
    const nrm = norm({x:-d.y, y:d.x});
    const wig = (6 + E*10) * DPR;
    const w = Math.sin((t*ROCKET_SPEED)*1.1 + segIdx*1.7) * wig;
    pos = add(pos, mul(nrm, w*0.06));

    return {x:pos.x, y:pos.y, dx:d.x, dy:d.y, visible:true};
  }

  function updateAndDrawRocket(t, dt, E){
    if(!ROCKET_ON) return;

    const p = getRocketPose(t, E);

    if(p.visible){
      addRocketTrail(p.x,p.y,t);
      drawRocketTrail(t, E);

      const l = Math.hypot(p.dx, p.dy) || 1;
      const vx = p.dx/l, vy = p.dy/l;
      const rot = Math.atan2(vy, vx); // UFO æ°´å¹³ï¼šä¸å†é¡å¤– +90Â°

      ctx.save();
      ctx.globalAlpha = ROCKET_ALPHA * (state.focusing ? 0.92 : 1.0);
      drawCuteRocket(p.x, p.y, rot, t, E);
      ctx.restore();
    }else{
      // è®“å°¾è·¡è‡ªç„¶æ¶ˆå¤±
      drawRocketTrail(t, E);
    }
  }
  // =========================================================

// ---------- Mirror EQ (NO GAP) ----------
  const BAR_TOTAL = 96;
  const BAR_HALF  = BAR_TOTAL / 2;
  let smoothBars  = new Float32Array(BAR_HALF);

  function gradNeon(){
    const g = ctx.createLinearGradient(W*0.22, H*0.62, W*0.78, H*0.40);
    g.addColorStop(0.0, `hsla(${(state.focusing?300:295)},100%,72%,.95)`);
    g.addColorStop(0.45, `hsla(205,100%,72%,.95)`);
    g.addColorStop(1.0, `hsla(275,100%,72%,.95)`);
    return g;
  }

  // ---------- Focus Wave Banner (å°ˆæ³¨ï¼šä¸­é–“æ©«å‘æ³¢å½¢ï¼Œåƒåƒè€ƒåœ–é‚£ç¨®ä¸€æ¢ç·š+æ³¢å½¢) ----------
  function drawFocusWaveBanner(t, E){
    if(!timeData || !analyser) return;

    // å– time-domain è®“æ³¢å½¢æ›´ã€Œèµ·ä¼ã€è€Œä¸æ˜¯åƒç‰†
    analyser.getByteTimeDomainData(timeData);

    const y = H * 0.66;              // å¤§æ¦‚åœ¨ç•«é¢ä¸‹åŠéƒ¨ï¼ˆæ¥è¿‘å°ˆæ³¨æ¡†çš„ä¸­ç·šï¼‰
    const left = W * 0.06;
    const right = W * 0.94;
    const span = right - left;

    const bars = 220;
    const step = span / bars;
    const barW = Math.max(1*DPR, step*0.82);

    const maxH = Math.max(44*DPR, H * 0.12); // èª¿å¤§ï¼šè¶…å°ˆæ³¨æ³¢å½¢æ›´æ˜é¡¯
    const boost = 1.25 + E*1.45; // èª¿å¤§ï¼šè¶…å°ˆæ³¨æ³¢å½¢èµ·ä¼æ›´å¤§

    // åŸºæº–ç·š
    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    ctx.globalAlpha = 0.55 + E*0.25;
    ctx.lineWidth = Math.max(1.2*DPR, 2);
    ctx.strokeStyle = 'rgba(255,255,255,0.42)';
    ctx.beginPath();
    ctx.moveTo(left, y);
    ctx.lineTo(right, y);
    ctx.stroke();

    const g = ctx.createLinearGradient(left, y, right, y);
    g.addColorStop(0.0, `hsla(295,100%,72%,0.82)`);
    g.addColorStop(0.45, `hsla(205,100%,74%,0.85)`);
    g.addColorStop(1.0, `hsla(275,100%,72%,0.82)`);

    // å…©å´æ·¡å‡ºï¼ˆèˆ’æœã€ä¸åˆºçœ¼ï¼‰
    const edgeFade = (x01)=> {
      // x01: 0..1
      const d = Math.abs(x01-0.5)*2; // center=0, edge=1
      return Math.max(0.10, 1 - Math.pow(d, 1.8));
    };

    ctx.fillStyle = g;

    // å¾ timeData å‡å‹»æŠ½æ¨£ï¼›ç”¨ |sample-128| åšã€ŒæŸ±ç‹€æ³¢å½¢ã€ï¼Œä¸Šä¸‹é¡åƒ
    for(let i=0;i<bars;i++){
      const x = left + i*step;
      const idx = Math.floor(i / bars * (timeData.length-1));
      const a = Math.pow(Math.abs(timeData[idx]-128)/128, 0.65);    // 0..1ï¼ˆæäº®å°èµ·ä¼ï¼‰
      const h = Math.min(maxH, a*maxH*boost);

      const alpha = (0.18 + 0.78*(h/maxH)) * edgeFade(i/(bars-1));
      ctx.globalAlpha = alpha;

      const x0 = x - barW/2;
      ctx.fillRect(x0, y - h, barW, h*2);
    }

    // æŸ”å…‰å¤–æšˆï¼ˆè¼•å¾®ï¼‰
    ctx.globalAlpha = 0.18 + E*0.14;
    ctx.strokeStyle = 'rgba(255,255,255,0.20)';
    ctx.lineWidth = Math.max(1*DPR, 1.6);
    ctx.beginPath();
    ctx.moveTo(left, y);
    ctx.lineTo(right, y);
    ctx.stroke();

    ctx.restore();
  }

  // ---------- EQ mapping (FULL-WIDTH) ----------
  // æŠŠé »è­œèƒ½é‡å¹³å‡é‹ªæ»¿æ•´å€‹å¯¬åº¦ï¼ˆå·¦å³é¡åƒï¼‰ï¼Œé¿å…ã€Œéæ¸¡å€ã€å› ç‚ºæ˜ å°„/æ¬Šé‡è€Œè®Šæˆç©ºç™½ã€‚
  // ä¿ç•™ buildEQMap() åç¨±ï¼Œè®“åŸæœ¬çš„åˆå§‹åŒ–å‘¼å«ä¸æœƒå‡ºéŒ¯ï¼ˆé€™è£¡å·²ä¸éœ€è¦éš¨æ©Ÿæ˜ å°„ï¼‰ã€‚
  function buildEQMap(){ /* no-op: full-width mapping */ }

  function sampleBinFullWidth(i, E){
    if(!freqData) return 0;
    const n = freqData.length;

    // i: 0(é ä¸­å¿ƒ=é«˜éŸ³) -> BAR_HALF-1(é å¤–å´=ä½éŸ³)
    const t = (BAR_HALF<=1) ? 0 : (i / (BAR_HALF - 1));

    // åå‘æ˜ å°„ï¼šä¸­å¿ƒå–é«˜é »ã€å¤–å´å–ä½é »ï¼ˆä½ è¦çš„ã€Œé«˜éŸ³åœ¨è£¡é¢ã€ä½éŸ³åœ¨å¤–é¢ã€ï¼‰
    // ä»ç”¨å°æ•¸æ„Ÿè¦ºåˆ†ä½ˆï¼Œè®“ä½é »(å¤–å´)æ›´å¯†é›†ã€é«˜é »(ä¸­å¿ƒ)æ›´ç¨€ç–ä½†æ›´å¹³æ»‘
    const idx0 = Math.min(n-1, Math.max(0, Math.floor(Math.pow(1 - t, 1.80) * (n - 1))));

    // é«˜é »æ¯”è¼ƒä¸ç©©ï¼šä¸­å¿ƒï¼ˆé«˜éŸ³ï¼‰å–æ›´å¤§ä¸€æ®µå¹³å‡ï¼Œè®“è·³å‹•æ›´èˆ’æœ
    const span = 2 + Math.floor((1 - t) * 6);
    let sum = 0, cnt = 0;
    for(let k=-span;k<=span;k++){
      const idx = idx0 + k;
      if(idx>=0 && idx<n){ sum += freqData[idx]; cnt++; }
    }

    let v = (cnt ? (sum/cnt) : freqData[idx0]) / 255;

    // é«˜é »é€šå¸¸èƒ½é‡è¼ƒå°ï¼šçµ¦ä¸­å¿ƒä¸€é»å¢ç›Šï¼›å¤–å´ï¼ˆä½é »ï¼‰åè€Œç¨å¾®æ”¶æ–‚ï¼Œé¿å…å…©ç«¯è®Šæˆã€Œé«˜ç‰†ã€
    const gain = 0.75 + 1.95 * Math.pow(1 - t, 1.15);
    v = Math.min(1, v * gain);

    // å¾®é‡åº•å™ªï¼ˆè·Ÿæ•´é«”èƒ½é‡ä¸€èµ·å‘¼å¸ï¼‰ï¼Œé¿å…æŸäº›é »æ®µå®Œå…¨è²¼å¹³
    const floor = 0.02 + (E||0) * 0.05;
    if(v < floor) v = floor;

    return v;
  }



  function drawMirrorEQ(timeSec, E){
    // åƒè€ƒä½ æä¾›çš„åœ–ï¼šåº•éƒ¨ä¸€æ¢æ°´å¹³åŸºæº–ç·š + ä¸Šä¸‹é¡åƒæŸ±ç‹€é »è­œï¼ˆå·¦å³å°ç¨±ã€ä¸ä¸­æ–·ï¼‰
    const cx = W*0.5;
    const cy = H*0.80;
    const maxH = Math.min(H*0.20, 240*DPR);

    const left  = W*0.05;
    const right = W*0.95;
    const halfSpan = (right - left) / 2;

    const step = halfSpan / BAR_HALF;
    const barW = Math.max(1*DPR, step*0.92);
    const gap  = Math.max(0, step - barW);

    const mirrorScale = 0.62;
    const mirrorAlpha = 0.75;

    const neon = gradNeon();

    ctx.save();
    ctx.globalCompositeOperation = 'lighter';

    // --- baseline (ä¸€æ¢ç·š) ---
    ctx.globalAlpha = 0.95;
    ctx.lineWidth = (2.4 + E*1.4) * DPR;
    ctx.strokeStyle = neon;
    ctx.shadowBlur = (14 + E*22) * DPR;
    ctx.shadowColor = `hsla(210,100%,75%,${0.22 + E*0.26})`;
    ctx.beginPath();
    ctx.moveTo(left, cy);
    ctx.lineTo(right, cy);
    ctx.stroke();

    // --- bars ---
    ctx.shadowBlur = (10 + E*18) * DPR;
    ctx.shadowColor = `hsla(210,100%,75%,${0.18 + E*0.22})`;
    ctx.fillStyle = neon;

    for(let i=0;i<BAR_HALF;i++){
      let v = 0.10 + 0.05*Math.sin(timeSec*1.1 + i*0.14);
      if(analyser && freqData && !bgAudio.paused){
        v = sampleBinFullWidth(i, E);
      }
      smoothBars[i] = smoothBars[i]*0.80 + v*0.20;

      const hUp = Math.max(2*DPR, smoothBars[i] * maxH * (0.60 + E*0.60));
      const hDn = hUp * mirrorScale;

      const xR = cx + i*(barW+gap);
      const xL = cx - (i+1)*(barW+gap);

      // è®“æ•´æ¢è¦–è¦ºè¦†è“‹åˆ°å·¦å³é‚Šç·£ï¼ˆä¸è¶…å‡ºï¼‰
      if(xR > right) break;
      if(xL < left) continue;

      ctx.globalAlpha = 1.0;
      ctx.fillRect(xR, cy - hUp, barW, hUp);
      ctx.fillRect(xL, cy - hUp, barW, hUp);

      ctx.globalAlpha = mirrorAlpha;
      ctx.fillRect(xR, cy, barW, hDn);
      ctx.fillRect(xL, cy, barW, hDn);
    }

    // --- soft glow (åŠ ä¸€é»å±¤æ¬¡ï¼Œä½†ä¸æœƒé–ƒå¾—åˆºçœ¼) ---
    ctx.shadowBlur = 0;
    ctx.globalAlpha = 1.0;
    const glow = ctx.createRadialGradient(cx, cy, 0, cx, cy, maxH*1.15);
    glow.addColorStop(0.0, `rgba(120,200,255,${0.05 + E*0.10})`);
    glow.addColorStop(0.55, `rgba(220,120,255,${0.04 + E*0.08})`);
    glow.addColorStop(1.0, `rgba(0,0,0,0)`);
    ctx.fillStyle = glow;
    ctx.fillRect(left, cy-maxH*1.1, right-left, maxH*2.2);

    ctx.restore();
  }

  // ---------- Orb ----------
  const ORB_POINTS = 180;
  let orbSmooth = new Float32Array(ORB_POINTS);
  let emaE = 0;
  let beat = 0;

  function drawOrb(timeSec, E, low, mid, hi){
    if(!state.focusing) return;

    const cx = W*0.5;
    const cy = H*0.46;
    const base = Math.min(W,H) * 0.20;

    emaE = emaE*0.92 + E*0.08;
    const trigger = (E > Math.max(0.28, emaE*1.35)) && (low > 0.18);
    beat = Math.max(0, beat - 0.03);
    if(trigger) beat = Math.min(1, beat + 0.22);

    const breath = 0.018*Math.sin(timeSec*1.2) + 0.014*Math.sin(timeSec*0.7+1.1);
    const pulse = (low*0.22 + E*0.16 + beat*0.20);
    const R = base * (1 + breath + pulse);

    for(let i=0;i<ORB_POINTS;i++){
      let v = 0.10 + 0.07*Math.sin(timeSec*2.0 + i*0.12);
      if(analyser && freqData && !bgAudio.paused){
        const idx = Math.min(freqData.length-1, Math.floor((i/ORB_POINTS) * (freqData.length-1)));
        v = (freqData[idx]/255);
      }
      orbSmooth[i] = orbSmooth[i]*0.82 + v*0.18;
    }

    ctx.save();
    ctx.globalCompositeOperation='screen';

    const neon = ctx.createLinearGradient(cx-R, cy-R, cx+R, cy+R);
    neon.addColorStop(0.0, `hsla(300,100%,72%,.95)`);
    neon.addColorStop(0.45, `hsla(205,100%,72%,.95)`);
    neon.addColorStop(1.0, `hsla(275,100%,72%,.95)`);

    ctx.shadowBlur = (18 + E*26) * DPR;
    ctx.shadowColor = `hsla(210,100%,75%,${0.20 + E*0.25})`;
    ctx.strokeStyle = neon;
    ctx.lineWidth = (2.2 + E*2.0) * DPR;

    ctx.beginPath();
    for(let i=0;i<ORB_POINTS;i++){
      const ang = (i/ORB_POINTS)*Math.PI*2;
      const dist = (orbSmooth[i] * 0.55 + E*0.18 + beat*0.22);
      const rr = R * (1 + dist*0.35
        + 0.06*Math.sin(ang*8 + timeSec*2.3)
        + 0.03*Math.sin(ang*16 - timeSec*2.9)
      );
      const x = cx + Math.cos(ang)*rr;
      const y = cy + Math.sin(ang)*rr;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.closePath();
    ctx.stroke();

    ctx.shadowBlur = (8 + E*16) * DPR;
    ctx.shadowColor = `hsla(290,100%,75%,${0.14 + E*0.18})`;
    ctx.lineWidth = (1.1 + E*1.2) * DPR;
    ctx.strokeStyle = `hsla(205,100%,78%,${0.20 + E*0.20})`;

    ctx.beginPath();
    for(let i=0;i<ORB_POINTS;i++){
      const ang = (i/ORB_POINTS)*Math.PI*2;
      const dist = (orbSmooth[i] * 0.40 + hi*0.18 + beat*0.18);
      const rr = R * 0.90 * (1 + dist*0.26);
      const x = cx + Math.cos(ang)*rr;
      const y = cy + Math.sin(ang)*rr;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.closePath();
    ctx.stroke();

    ctx.shadowBlur = 0;
    ctx.fillStyle = `rgba(255,255,255,${0.06 + E*0.10})`;
    const dotCount = 260;
    for(let i=0;i<dotCount;i++){
      const ang = (i/dotCount)*Math.PI*2 + timeSec*0.18;
      const rr = R * (0.90 + 0.05*Math.sin(ang*4 + timeSec*1.6) + orbSmooth[Math.floor((i/dotCount)*(ORB_POINTS-1))]*0.08);
      const x = cx + Math.cos(ang)*rr;
      const y = cy + Math.sin(ang)*rr;
      const sz = (0.6 + E*1.2) * DPR;
      ctx.beginPath();
      ctx.arc(x,y,sz,0,Math.PI*2);
      ctx.fill();
    }

    if(beat > 0.02){
      const burst = ctx.createRadialGradient(cx + R*0.28, cy - R*0.22, 0, cx, cy, R*1.2);
      burst.addColorStop(0.0, `hsla(205,100%,75%,${beat*0.28})`);
      burst.addColorStop(0.40, `hsla(285,100%,75%,${beat*0.12})`);
      burst.addColorStop(1.0, `rgba(0,0,0,0)`);
      ctx.fillStyle = burst;
      ctx.beginPath();
      ctx.arc(cx,cy,R*1.25,0,Math.PI*2);
      ctx.fill();
    }

    ctx.restore();
  }

  // ---------- Resize / Init ----------
  function resize(){
    DPR = chooseDPR();
    W = Math.floor(window.innerWidth * DPR);
    H = Math.floor(window.innerHeight * DPR);
    canvas.width = W;
    canvas.height = H;

    initStars();
    buildNebula();
    rocketRoute = null; routeAnchor = -1; buildRocketRoute(); // âœ… ç«ç®­è·¯å¾‘è·Ÿè‘—è¦–çª—é‡å»º
  }
  window.addEventListener('resize', resize);

  // ---------- Main loop (NO TRAIL for stars, trail only for rocket) ----------
  const TARGET_FPS = 60; // 4K / P60ï¼šé– 60FPSï¼ˆæ›´ç©©ï¼‰
  const FRAME_INTERVAL = 1000 / TARGET_FPS;
  let lastT = performance.now();
  function frame(now){
    const deltaMs = now - lastT;
    if(deltaMs < FRAME_INTERVAL){
      requestAnimationFrame(frame);
      return;
    }
    const t = now/1000;
    const dt = Math.min(0.05, deltaMs/1000);
    lastT = now;

    ctx.clearRect(0,0,W,H);

    let E=0, low=0, mid=0, hi=0;
    if(analyser && freqData){
      if(!bgAudio.paused){
        ({E,low,mid,hi} = getEnergy());
      }else{
        E = 0.06 + 0.05*Math.sin(t*0.8);
        low = E*0.8; mid = E*0.6; hi = E*0.5;
      }
    }else{
      E = 0.06 + 0.05*Math.sin(t*0.8);
      low = E*0.8; mid = E*0.6; hi = E*0.5;
    }

    drawNebula(t, E);
    drawStars(t, E);

    // åªæœ‰é€²å…¥ã€Œè¶…å°ˆæ³¨æ¨¡å¼ã€æ‰é¡¯ç¤ºï¼šæµæ˜Ÿ / å¹½æµ® / æ³¢å½¢ï¼ˆå«åŸºæº–ç·šï¼‰
    if(state.focusing){
      updateAndDrawMeteors(dt, E);

      // âœ… å¹½æµ®åœ¨èƒŒæ™¯ä¸Šå±¤ã€ä½†åœ¨ EQ/çƒä¹‹å‰ï¼ˆçœ‹èµ·ä¾†æœ€é †ï¼‰
      updateAndDrawRocket(t, dt, E);

      drawFocusWaveBanner(t, E);
    }

    // æœªé€²å…¥è¶…å°ˆæ³¨ï¼šä¸é¡¯ç¤ºåº•éƒ¨æ³¢å½¢/ç·šã€ä¸é¡¯ç¤ºå¹½æµ®ã€ä¸é¡¯ç¤ºæµæ˜Ÿï¼›åªç•™å¾€ä¸‹å¢œçš„æ˜Ÿæ˜Ÿï¼ˆdrawStarsï¼‰
    drawOrb(t, E, low, mid, hi);

    requestAnimationFrame(frame);
  }

  // ---------- Init ----------
  
  // ---------- Built-in playlist (for GitHub Pages) ----------
  // ä½ åªè¦æŠŠéŸ³æ¨‚æª”æ”¾é€² repo çš„ /music/ è³‡æ–™å¤¾ï¼Œå°±èƒ½åœ¨é€™è£¡ç›´æ¥é¸æ­Œï¼Œä¸ç”¨å†ä¸Šå‚³ MP3ã€‚
  function initBuiltInPlaylist(){
    const builtIn = [
      { name: 'åšäººçš„å°æ›² - Vaundy', src: 'music/lofi.mp3' },
      { name: 'è¸Šã‚Šå­ - Vaundy', src: 'music/vaundy_odorigoko.mp3' },
      // ä¹‹å¾Œè¦åŠ æ­Œï¼šæŠŠ mp3 æ”¾åˆ° /music/ï¼Œå†åœ¨é€™è£¡æ–°å¢ä¸€è¡Œå³å¯
      // { name: 'Cyber Lofi', src: 'music/cyber_lofi.mp3' },
    ];

    // é‡å»ºä¸‹æ‹‰æ­Œå–®
    trackSelect.innerHTML = '';
    for(const t of builtIn){
      const opt = document.createElement('option');
      opt.value = t.src;
      opt.textContent = t.name;
      trackSelect.appendChild(opt);
    }

    // è¨­å®šæ’­æ”¾é †åºï¼ˆä¸Šä¸€é¦–/ä¸‹ä¸€é¦–æœƒä¾ç…§é€™å€‹é †åºè·‘ï¼‰
    state.music.order = builtIn.map(t=>t.src);
    saveState();

    // å›åˆ°ä¸Šæ¬¡é¸çš„æ­Œï¼ˆå¦‚æœé‚„å­˜åœ¨ï¼‰
    if(state.music.lastTrackId && state.music.order.includes(state.music.lastTrackId)){
      trackSelect.value = state.music.lastTrackId;
    }else{
      trackSelect.value = builtIn[0]?.src || '';
      state.music.lastTrackId = trackSelect.value || null;
      saveState();
    }

    rebuildQueue(true);
  }

async function init(){
    remainMs = getModeMs(state.mode);
    syncVol();
    resize();
    syncFsChip();

    initBuiltInPlaylist();
    await loadSelectedTrack();


    render();
    requestAnimationFrame(frame);
  }

  bgAudio.addEventListener('play', ()=>{
    ensureAudioGraph();
    analyser.getByteFrequencyData(freqData);
  });

  init();
})();
</script>
</body>
</html>
